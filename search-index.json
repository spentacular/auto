[
  {
    "path": [
      "Welcome",
      "Workflow"
    ],
    "url": "docs#workflow",
    "content": "\nauto's main use it to automate the release process for your project.\nThis can be broken down into three core steps:\npre: (optional) Check if new version\n\n1. Generate CHANGELOG.md\n2. Publish code\n3. Generate github release notes\npre: (optional) Check if new version\n\n1. Generate CHANGELOG.md\n2. Publish code\n3. Generate github release notes\n\nauto makes no assumptions about your publishing process.\nEach tool is a function that can be run in isolation and only does one thing really well.\nFor instance, you could just use auto changelog to generate the changelog and nothing else or use auto version to calculate just the semver bump.\nGet Started 🎉"
  },
  {
    "path": [
      "Blog",
      "Best of Both Worlds"
    ],
    "url": "blog/both-worlds",
    "content": "\nOne of the main goals we had when building auto was to ease the introduction to automated releases through using pull request labels.\nThe main alternative to auto works in a slightly different way, semantic-release uses the conventional commit spec to calculate the next version. This is an awesome way to accomplish automated releases, but it is very strict and can create more work when accepting outside contribution. PR labels solve this problem beautifully, but...\n\nThat's exactly why we made the conventional-commits plugin. It allows you to keep your conventional commit work flow but still get the benefits of PR labels based automation.\nTo start using conventional commit style commit messages simply add the following to your auto config.\n{\n  \"plugins\": [\"conventional-commits\"]\n}\n{\n  \"plugins\": [\"conventional-commits\"]\n}\n\nNow you can enjoy the best of both worlds! 🎉"
  },
  {
    "path": [
      "Blog",
      "npm: More Secure Canary Publishing"
    ],
    "url": "blog/npm-canary-scope",
    "content": "\nPublishing canary versions comes with some security risks.\nIf your project is private you have nothing to worry about, but if your project is open source there are some security holes."
  },
  {
    "path": [
      "Blog",
      "npm: More Secure Canary Publishing",
      "Attack Vectors"
    ],
    "url": "blog/npm-canary-scope#attack-vectors",
    "content": "\nDepending on the build platform you might be able to pass secrets to PR builds for forked repos.\nWhile this makes the developer experience of your project nice, in auto's case publishing canary versions, it exposes your keys.\nAn attacker could:\nprint secretssend secrets to some servermodify auto to publish to the latest tag instead of canary\nNo amount of code can fix these problems.\nIf your release keys are in everyone's CI builds an attacker can do any number of things to modify what you intend for auto to do (or any other release method run in the CI)."
  },
  {
    "path": [
      "Blog",
      "npm: More Secure Canary Publishing",
      "Solution"
    ],
    "url": "blog/npm-canary-scope#solution",
    "content": "\nThe solution for this is actually quite simple:\nCreate a test scope that you publish canaries under (ex: @auto-canary or @auto-test)Create a user that only has access to that scopeSet the default NPM_TOKEN to a token that can publish to that scope (this is used for any pull request)Set up a secure token that is only accessible on the main fork (still named NPM_TOKEN)\nStep 3 might not be possible on your build platform.\nThe following are the ways the auto team knows how to do it.\nIf you do not see the method for you build platform, please make a pull request!\nCircleCI Context - Contexts provide a mechanism for securing and sharing environment variables across projects. The environment variables are defined as name/value pairs and are injected at runtime."
  },
  {
    "path": [
      "Blog",
      "npm: More Secure Canary Publishing",
      "Usage"
    ],
    "url": "blog/npm-canary-scope#usage",
    "content": "\nTo use this work flow in auto, supply the following configuration to the npm plugin.\n{\n  \"plugins\": [\n    [\n      \"npm\",\n      {\n        \"canaryScope\": \"@auto-canary\"\n      }\n    ]\n  ]\n}\n{\n  \"plugins\": [\n    [\n      \"npm\",\n      {\n        \"canaryScope\": \"@auto-canary\"\n      }\n    ]\n  ]\n}\n\nNow when people make pull requests to your repos:\nyour CI can run auto shipitthe canary versions will get published under your canaryScope"
  },
  {
    "path": [
      "Blog",
      "Merging PRs to other PRs"
    ],
    "url": "blog/pr-in-progress",
    "content": "\nSometimes you are working on a big feature and you know it will require a lot of changes. These types of pull requests can be a nightmare to review. Taking in all the changes at once can be overwhelming. It makes it easy to miss smaller mistakes and can make it hard to guess the intent of the changes. Multiple features, bug fixes, or even breaking changes may make up this large PR.\nOne way to manage this problem is by making a PR to the large PR. Other contributors can review a smaller subset of changes and also follow along with development. In previous versions of auto, large PRs would not be represented well in the changelog and release notes. It would only include the main PR that got merged into baseBranch as the only changelog note.\nBut thanks to this PR that isn't true anymore! Now when you merge one PR to another both changes will be represented in the changelog.\n\nScore!\n\nFor example in PR #351 we changed what happens when you call shipit from a PR. Previously if you called shipit it would create a new release and publish it to the latest tag. The PR made it so shipit would create a canary release when run in a PR and only publish to latest from the master branch.\nAnother contributor to the project pointed out that some users might not be using master as their base branch, so the baseBranch should be configurable.\nInstead of waiting for #351 to get merged to write the baseBranch functionality, I could make a PR to #351 and both PRs would be represented in the changelog!\n\n\n\n\nNow you can be a little more creative with how you manage large PR and have even more detailed changelogs."
  },
  {
    "path": [
      "Blog",
      "Stress-free Continuous Delivery with auto"
    ],
    "url": "blog/using-shipit",
    "content": "\nauto makes releasing your code a breeze. Instead of manually calculating a version and doing your whole release process manually, auto takes care of it for you.\nThe main command most users use to interact with auto is the shipit command. shipit does all the heaving lifting when releasing your code.\nWhen run on baseBranch it will:\nDetermine if the last merged PR needs to be releasedUpdate a CHANGELOG.md with all you new changesPublish to NPMMake a release on GitHub and mark it as latest\nWhen run from a PR or locally it will create a canary version.\n"
  },
  {
    "path": [
      "Blog",
      "Stress-free Continuous Delivery with auto",
      "How does it work?"
    ],
    "url": "blog/using-shipit#how-does-it-work",
    "content": "\nauto does all this magic through GitHub labels. This makes managing outside contribution super easy. Contributors code, you determine the appropriate label, and auto takes care of the rest.\nThere are a few types of labels:\nRelease LabelsChangelog LabelsArbitrary labels\n"
  },
  {
    "path": [
      "Blog",
      "Stress-free Continuous Delivery with auto",
      "How does it work?",
      "Release Labels"
    ],
    "url": "blog/using-shipit#release-labels",
    "content": "\nThese labels will help you release semantically versioned packages. If no label is present auto assumes the PR is a patch.\nmajor: The PR changes the public API in some way. Create a major releaseminor: The PR adds a feature to the public API. Create a minor releasepatch: The PR fixes a bug. Create a patch releaseskip-release: The PR should not be released. This labels can be used in conjunction with the previous labels for when the PR is actually releasedinternal: Changes only effect how the app is structured or something that doesn't effect the user. This counts as a patch release"
  },
  {
    "path": [
      "Blog",
      "Stress-free Continuous Delivery with auto",
      "How does it work?",
      "Changelog Labels"
    ],
    "url": "blog/using-shipit#changelog-labels",
    "content": "\nThese labels can be used to make your changelogs more expressive. Add them to PRs with release labels to override what changelog section the changes display in. Or use them on their own to just create a patch release.\nYou can configure more changelog sections, read more here."
  },
  {
    "path": [
      "Blog",
      "Stress-free Continuous Delivery with auto",
      "How does it work?",
      "Arbitrary labels"
    ],
    "url": "blog/using-shipit#arbitrary-labels",
    "content": "\nauto doesn't use any extra labels, but you can use whatever labels to power more automated workflows with auto label. This command will return the labels for a PR. Using that information you can choose to run extra CI jobs.\nFor example,. the following will only run the test:visual script when the PR has has the Visual label.\nexport PATH=$(npm bin):$PATH\n\nif auto label --pr $PR_NUMBER --exists Visual;\nthen\n    npm run test:visual\nfi\nexport PATH=$(npm bin):$PATH\n\nif auto label --pr $PR_NUMBER --exists Visual;\nthen\n    npm run test:visual\nfi\n\n"
  },
  {
    "path": [
      "Blog",
      "Stress-free Continuous Delivery with auto",
      "Wrapping Up"
    ],
    "url": "blog/using-shipit#wrapping-up",
    "content": "\nNow that you know all of the above, you have all you need to release every build as the correct version. No longer worry what tag to publish to or what version. You should never really have to run auto yourself, the CI will do that on each build!\nAll you have to know is what the labels are and when to use them.\nIf you have any questions about how to use auto feel free to ask! I hope you guys enjoy the automated release process! 🎁"
  },
  {
    "path": [
      "Blog",
      "Announcing \"auto\" 8.0.0"
    ],
    "url": "blog/v8",
    "content": "\nWe are excited to announce the release of auto 8.0.0.\nThis release brings a new command next, a new use for shipit, more powerful label configuration, and more.\nIf you are unfamiliar, auto is a CLI tool which helps you version your code and automate any part of your release pipeline.\nauto's main use is for automating your versioning with semantic versioning and GitHub pull request labels.\nIt handles determining the next version, creating changelogs, publishing to package managers, publishing GitHub Releases, and so much more through plugins.\nIf you aren't already using auto you can either install it through npm:\nnpm install auto\nnpm install auto\n\nOr if you are publishing to something other than npm:\n# On OSX\nbrew tap intuit/auto https://github.com/intuit/auto\nbrew install auto\n\n# Or other OSs\n# Download a platform specific version of auto\ncurl -vkL -o - https://github.com/intuit/auto/releases/download/v8.0.0/auto-linux.gz | gunzip > ~/auto\n# Make auto executable\nchmod a+x ~/auto\n# On OSX\nbrew tap intuit/auto https://github.com/intuit/auto\nbrew install auto\n\n# Or other OSs\n# Download a platform specific version of auto\ncurl -vkL -o - https://github.com/intuit/auto/releases/download/v8.0.0/auto-linux.gz | gunzip > ~/auto\n# Make auto executable\nchmod a+x ~/auto\n"
  },
  {
    "path": [
      "Blog",
      "Announcing \"auto\" 8.0.0",
      "next Command"
    ],
    "url": "blog/v8#next-command",
    "content": "\nThis new command will make a preview release of your code. This entails:\nCreating a prerelease on package management platform (supported by npm and git-tag plugins)Creating a tag and \"Pre Release\" on GitHub releases page\nThe only prerelease branch auto comes configured with is next.\nYou can configure as many branches as you want with the prereleaseBranches .autorc option.\nIf your package manager plugin supports release tags, such as the npm plugin, auto will publish the prerelease branch to a tag of the same name.\nCalling auto next from a one of these branches will publish a prerelease, otherwise it will publish to your default prerelease branch/tag."
  },
  {
    "path": [
      "Blog",
      "Announcing \"auto\" 8.0.0",
      "next Command",
      "Example Usage"
    ],
    "url": "blog/v8#example-usage",
    "content": "\nGiven the following configuration:\n{\n  \"prereleaseBranches\": [\"beta\"]\n}\n{\n  \"prereleaseBranches\": [\"beta\"]\n}\n\nRun auto next from beta branch => Publish prerelease to beta tag.\nRun auto next from feature branch => Publish prerelease to beta tag."
  },
  {
    "path": [
      "Blog",
      "Announcing \"auto\" 8.0.0",
      "Prerelease Branches with shipit"
    ],
    "url": "blog/v8#prerelease-branches-with-shipit",
    "content": "\nThe shipit command will now also publish a prerelease when ran from a prerelease branch. You can use this in a few different ways:\nTwo release branches: baseBranch and nextWithout next Branch (--only-graduate-with-release-label)Multiple next Branches (ex: alpha, beta, rc)Feature Pre-releases\nRead more here."
  },
  {
    "path": [
      "Blog",
      "Announcing \"auto\" 8.0.0",
      "Label Configuration"
    ],
    "url": "blog/v8#label-configuration",
    "content": "\nLabel configuration just got a whole lot simpler 🎉.\nLabels can now only be supplied as an array of label objects.{\n  \"labels\": [\n    { \"releaseType\": \"major\", \"name\": \"Version: Major\" },\n    { \"releaseType\": \"minor\", \"name\": \"Version: Minor\" },\n    { \"releaseType\": \"patch\", \"name\": \"Version: Patch\" }\n  ]\n}\n{\n  \"labels\": [\n    { \"releaseType\": \"major\", \"name\": \"Version: Major\" },\n    { \"releaseType\": \"minor\", \"name\": \"Version: Minor\" },\n    { \"releaseType\": \"patch\", \"name\": \"Version: Patch\" }\n  ]\n}\nInstead of using skipReleaseLabels just set the label's type to skip{\n  \"labels\": [{ \"releaseType\": \"skip\", \"name\": \"NO!\" }]\n}\n{\n  \"labels\": [{ \"releaseType\": \"skip\", \"name\": \"NO!\" }]\n}\nOverwrite default labels using overwrite{\n  \"labels\": [\n    { \"releaseType\": \"major\", \"name\": \"Version: Major\", \"overwrite\": true }\n  ]\n}\n{\n  \"labels\": [\n    { \"releaseType\": \"major\", \"name\": \"Version: Major\", \"overwrite\": true }\n  ]\n}\nAdd none releaseType. This will act as a skip-release unless paired with a SEMVER label{\n  \"labels\": [{ \"releaseType\": \"none\", \"name\": \"documentation\" }]\n}\n{\n  \"labels\": [{ \"releaseType\": \"none\", \"name\": \"documentation\" }]\n}\nChanged title to changelogTitle.{\n  \"labels\": [{ \"changelogTitle\": \"New Docs Yo!\", \"name\": \"documentation\" }]\n}\n{\n  \"labels\": [{ \"changelogTitle\": \"New Docs Yo!\", \"name\": \"documentation\" }]\n}\n"
  },
  {
    "path": [
      "Blog",
      "Announcing \"auto\" 8.0.0",
      "Upload Assets - Globs"
    ],
    "url": "blog/v8#upload-assets---globs",
    "content": "\nYou might want to upload multiple files or you might not know the file-name (ex: a vscode extension w/ a version number in the name), but you know the pattern of the filenames that you want to upload.\nSo now you can use globs!\n{\n  \"plugins\": [[\"upload-assets\", [\"./path/**/to/*.file\"]]]\n}\n{\n  \"plugins\": [[\"upload-assets\", [\"./path/**/to/*.file\"]]]\n}\n"
  },
  {
    "path": [
      "Blog",
      "Announcing \"auto\" 8.0.0",
      "💥 Other Notable Breaking Changes"
    ],
    "url": "blog/v8#-other-notable-breaking-changes",
    "content": ""
  },
  {
    "path": [
      "Blog",
      "Announcing \"auto\" 8.0.0",
      "💥 Other Notable Breaking Changes",
      "Deprecate --very-verbose, -w Flag"
    ],
    "url": "blog/v8#deprecate---very-verbose--w-flag",
    "content": "\nUsing -w for very verbose logs was a very odd choice on my part (two vs next to each other look like a w 😓).\nInstead you can now just add another -v and get the very verbose logs!\n# old\nauto shipit -w\n\n# new\nauto shipit -vv\n# or\nauto shipit --verbose --verbose\n# old\nauto shipit -w\n\n# new\nauto shipit -vv\n# or\nauto shipit --verbose --verbose\n\n\nWe hope you enjoy the new ways you can release your code!\n– Andrew Lisowski and the auto Team\nView the full release notes."
  },
  {
    "path": [
      "Blog",
      "Death to Monotony"
    ],
    "url": "blog/why",
    "content": ""
  },
  {
    "path": [
      "Continuous Integration",
      "CircleCI"
    ],
    "url": "docs/build-platforms/circleci",
    "content": "\nThe following config declares the release job and uses it in the build_and_release workflow. The release job will run at the end of each build and either release:\na new latest version from baseBrancha canary build from a pull request (if your package manager plugin implements them)\nversion: 2\n\ndefaults: &defaults\n  working_directory: ~/auto\n  docker:\n    - image: circleci/node:latest-browsers\n\njobs:\n  install: # your install job\n\n  release:\n    <<: *defaults\n    steps:\n      - attach_workspace:\n          at: ~/auto\n      - run:\n          name: Release\n          command: npx auto shipit\n\nworkflows:\n  version: 2\n  build_and_release:\n    jobs:\n      - install\n\n      - release:\n          requires:\n            - install\nversion: 2\n\ndefaults: &defaults\n  working_directory: ~/auto\n  docker:\n    - image: circleci/node:latest-browsers\n\njobs:\n  install: # your install job\n\n  release:\n    <<: *defaults\n    steps:\n      - attach_workspace:\n          at: ~/auto\n      - run:\n          name: Release\n          command: npx auto shipit\n\nworkflows:\n  version: 2\n  build_and_release:\n    jobs:\n      - install\n\n      - release:\n          requires:\n            - install\n"
  },
  {
    "path": [
      "Continuous Integration",
      "CircleCI",
      "Troubleshooting"
    ],
    "url": "docs/build-platforms/circleci#troubleshooting",
    "content": "\nIf you are having problems make sure you have done the following:\nGH_TOKEN is setAny other secrets for plugins are set (Ex; NPM_TOKEN with the NPM plugin)"
  },
  {
    "path": [
      "Continuous Integration",
      "CircleCI",
      "Troubleshooting",
      "Problems pushing tags to github"
    ],
    "url": "docs/build-platforms/circleci#problems-pushing-tags-to-github",
    "content": "\nGo to Settings -> Checkout SSH Keys -> Create and add YOUR_USERNAME user key. This will create a key with the ability to push to github."
  },
  {
    "path": [
      "Continuous Integration",
      "CircleCI",
      "Examples"
    ],
    "url": "docs/build-platforms/circleci#examples",
    "content": "\nautoreaction"
  },
  {
    "path": [
      "Continuous Integration",
      "GitHub Actions"
    ],
    "url": "docs/build-platforms/github-actions",
    "content": "\nThe following config declares the release action that run on all branches. The job will either release:\na new latest version from baseBrancha canary build from a pull request (only on the main fork and if your package manager plugin implements them)\n.github/workflows/release.yml\n⚠️ You must use some sort of action that implements skip ci functionality (as seen below). Otherwise you will get stuck in a release loop!\nname: Release\n\non: [push]\n\njobs:\n  release:\n    runs-on: ubuntu-latest\n    if: \"!contains(github.event.head_commit.message, 'ci skip') && !contains(github.event.head_commit.message, 'skip ci')\"\n    steps:\n      - uses: actions/checkout@v2\n\n      - name: Prepare repository\n        run: git fetch --unshallow --tags\n\n      - name: Use Node.js 12.x\n        uses: actions/setup-node@v1\n        with:\n          node-version: 12.x\n\n      - name: Cache node modules\n        uses: actions/cache@v1\n        with:\n          path: node_modules\n          key: yarn-deps-${{ hashFiles('yarn.lock') }}\n          restore-keys: |\n            yarn-deps-${{ hashFiles('yarn.lock') }}\n\n      - name: Create Release\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}\n        run: |\n          yarn install --frozen-lockfile\n          yarn build\n          npx auto shipit\nname: Release\n\non: [push]\n\njobs:\n  release:\n    runs-on: ubuntu-latest\n    if: \"!contains(github.event.head_commit.message, 'ci skip') && !contains(github.event.head_commit.message, 'skip ci')\"\n    steps:\n      - uses: actions/checkout@v2\n\n      - name: Prepare repository\n        run: git fetch --unshallow --tags\n\n      - name: Use Node.js 12.x\n        uses: actions/setup-node@v1\n        with:\n          node-version: 12.x\n\n      - name: Cache node modules\n        uses: actions/cache@v1\n        with:\n          path: node_modules\n          key: yarn-deps-${{ hashFiles('yarn.lock') }}\n          restore-keys: |\n            yarn-deps-${{ hashFiles('yarn.lock') }}\n\n      - name: Create Release\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}\n        run: |\n          yarn install --frozen-lockfile\n          yarn build\n          npx auto shipit\n"
  },
  {
    "path": [
      "Continuous Integration",
      "GitHub Actions",
      "Troubleshooting"
    ],
    "url": "docs/build-platforms/github-actions#troubleshooting",
    "content": "\nIf you are having problems make sure you have done the following:\nAny required secrets for plugins are set (e.g. NPM_TOKEN with the NPM plugin)Update references of <your-github-user>, <project-owner>, and <project-repo> with the appropriate values"
  },
  {
    "path": [
      "Continuous Integration",
      "GitHub Actions",
      "Troubleshooting",
      "Running With Branch Protection"
    ],
    "url": "docs/build-platforms/github-actions#running-with-branch-protection",
    "content": "\nGitHub actions require a little more setup to use auto with branch protection.\nWe can't use the GITHUB_TOKEN to commit to the branch because it does not have high enough permissions.\nYou will need to create a token with admin access to your repo and modify your build config like the following:\nsteps:\n  - uses: actions/checkout@v2\n    with:\n      # Ensure that git uses your token with admin access to the repo\n      token: ${{ secrets.ADMIN_TOKEN }}\n\n  - name: Prepare repository\n    # Fetch full git history and tags\n    run: git fetch --unshallow --tags\nsteps:\n  - uses: actions/checkout@v2\n    with:\n      # Ensure that git uses your token with admin access to the repo\n      token: ${{ secrets.ADMIN_TOKEN }}\n\n  - name: Prepare repository\n    # Fetch full git history and tags\n    run: git fetch --unshallow --tags\n"
  },
  {
    "path": [
      "Continuous Integration",
      "GitHub Actions",
      "Examples"
    ],
    "url": "docs/build-platforms/github-actions#examples",
    "content": "\nauto-config-hipstersmoothiecreate-checkoctokit-cliauto-lerna-gh-actions"
  },
  {
    "path": [
      "Continuous Integration",
      "Jenkins 2"
    ],
    "url": "docs/build-platforms/jenkins",
    "content": "\nThe following config declares the release action that run on all branches. The job will either release:\na new latest version from baseBrancha canary build from a pull request (only if your package manager plugin supports it)\nJenkinsfile\n⚠️ You must use some sort of step that implements skip ci functionality.\nOtherwise you will get stuck in a release loop!\npipeline {\n  environment {\n    NPM_TOKEN = credentials('NPM_TOKEN')\n    GH_USER = credentials('GH_USER')\n    GH_TOKEN = credentials('GH_TOKEN')\n  }\n  stages {\n    stage('Check Skip CI') {\n      steps {\n        script {\n          result = sh (script: \"git log -1 | grep '.*\\\\[skip ci\\\\].*'\", returnStatus: true)\n          if (result == 0) {\n              echo (\"'Skip CI' spotted in git commit. Aborting.\")\n              currentBuild.result = 'ABORTED'\n              error('Exiting job');\n          }\n        }\n      }\n    }\n    stage('Prepare repository') {\n      steps {\n        // Jenkins will do weird things to \"origin\" in PR and branch build\n        // To get around this reset the \"origin\" back to normal\n        // This is only necessary if you are making next/pre-releases\n        sh 'git config --unset-all remote.origin.fetch'\n        sh 'git config --add remote.origin.fetch +refs/heads/*:refs/remotes/origin/*'\n        // Ensure you have all branches and tags\n        sh 'git fetch origin --tags'\n      }\n    }\n    stage('Install') {\n      steps {\n        sh 'yarn install --frozen-lockfile'\n      }\n    }\n    stage('Build') {\n      steps {\n          sh 'yarn build'\n      }\n    }\n    stage('Publish') {\n      parallel {\n        stage('Canary') {\n          when { changeRequest(); }\n          steps {\n            sh \"auto shipit\"\n          }\n        }\n        stage('Latest') {\n          when { branch 'main' }\n          steps {\n            // Jenkins will leave you in a detached HEAD state during builds\n            // Make sure to checkout your baseBranch here or the push will fail!\n            // The error will look like the following:\n            // error: src refspec main does not match any\n            sh 'git checkout -b main'\n            sh 'auto shipit'\n          }\n        }\n      }\n    }\n    stage('Canary') {\n      when { changeRequest() }\n      steps {\n        sh 'auto canary --pr $CHANGE_ID --build $BUILD_NUMBER'\n      }\n    }\n  }\n}\npipeline {\n  environment {\n    NPM_TOKEN = credentials('NPM_TOKEN')\n    GH_USER = credentials('GH_USER')\n    GH_TOKEN = credentials('GH_TOKEN')\n  }\n  stages {\n    stage('Check Skip CI') {\n      steps {\n        script {\n          result = sh (script: \"git log -1 | grep '.*\\\\[skip ci\\\\].*'\", returnStatus: true)\n          if (result == 0) {\n              echo (\"'Skip CI' spotted in git commit. Aborting.\")\n              currentBuild.result = 'ABORTED'\n              error('Exiting job');\n          }\n        }\n      }\n    }\n    stage('Prepare repository') {\n      steps {\n        // Jenkins will do weird things to \"origin\" in PR and branch build\n        // To get around this reset the \"origin\" back to normal\n        // This is only necessary if you are making next/pre-releases\n        sh 'git config --unset-all remote.origin.fetch'\n        sh 'git config --add remote.origin.fetch +refs/heads/*:refs/remotes/origin/*'\n        // Ensure you have all branches and tags\n        sh 'git fetch origin --tags'\n      }\n    }\n    stage('Install') {\n      steps {\n        sh 'yarn install --frozen-lockfile'\n      }\n    }\n    stage('Build') {\n      steps {\n          sh 'yarn build'\n      }\n    }\n    stage('Publish') {\n      parallel {\n        stage('Canary') {\n          when { changeRequest(); }\n          steps {\n            sh \"auto shipit\"\n          }\n        }\n        stage('Latest') {\n          when { branch 'main' }\n          steps {\n            // Jenkins will leave you in a detached HEAD state during builds\n            // Make sure to checkout your baseBranch here or the push will fail!\n            // The error will look like the following:\n            // error: src refspec main does not match any\n            sh 'git checkout -b main'\n            sh 'auto shipit'\n          }\n        }\n      }\n    }\n    stage('Canary') {\n      when { changeRequest() }\n      steps {\n        sh 'auto canary --pr $CHANGE_ID --build $BUILD_NUMBER'\n      }\n    }\n  }\n}\n"
  },
  {
    "path": [
      "Continuous Integration",
      "Jenkins 2",
      "Configuring Prereleases"
    ],
    "url": "docs/build-platforms/jenkins#configuring-prereleases",
    "content": "\nFor auto's prerelease to work you need to makes sure that you jenkins instance is configured correctly.\nGo to General > Projects > GitHub Organization and add a Behaviors that enables branch builds.Add this to the top of your Jenkinsfile.// Exit the branch build if not on \"baseBranch\" or a prerelease, but still do PR builds\nif (env.BRANCH_NAME != \"master\" && env.BRANCH_NAME != \"next\" && !env.BRANCH_NAME.startsWith('PR-')) {\n  echo (\"Aborting build. Only the master/next branch and PR builds run.\")\n  currentBuild.result = 'SUCCESS'\n  return\n }\n// Exit the branch build if not on \"baseBranch\" or a prerelease, but still do PR builds\nif (env.BRANCH_NAME != \"master\" && env.BRANCH_NAME != \"next\" && !env.BRANCH_NAME.startsWith('PR-')) {\n  echo (\"Aborting build. Only the master/next branch and PR builds run.\")\n  currentBuild.result = 'SUCCESS'\n  return\n }\nIf your successful you will see two separate builds in your PRs: pr-merge and branch.Modify your canary stage to not build the prerelease branchstage('Canary') {\n  when {\n    allOf {\n      changeRequest();\n      expression { env.CHANGE_BRANCH != 'next' }\n    }\n  }\n  steps {\n    sh \"auto shipit\"\n  }\n}\nstage('Canary') {\n  when {\n    allOf {\n      changeRequest();\n      expression { env.CHANGE_BRANCH != 'next' }\n    }\n  }\n  steps {\n    sh \"auto shipit\"\n  }\n}\nAdd a stage for the prereleasestage('Next') {\n  when { branch 'next' }\n  steps {\n    sh 'git checkout -b next'\n    sh \"auto shipit\"\n  }\n}\nstage('Next') {\n  when { branch 'next' }\n  steps {\n    sh 'git checkout -b next'\n    sh \"auto shipit\"\n  }\n}\nOpen a PR from your prerelease branch into your baseBranch and enjoy your prerelease! 🎉"
  },
  {
    "path": [
      "Continuous Integration",
      "Jenkins 2",
      "Troubleshooting"
    ],
    "url": "docs/build-platforms/jenkins#troubleshooting",
    "content": "\nIf you are having problems make sure you have done the following:\nGH_TOKEN is setAny other secrets for plugins are set (Ex; NPM_TOKEN with the NPM plugin)"
  },
  {
    "path": [
      "Continuous Integration",
      "Travis CI"
    ],
    "url": "docs/build-platforms/travis",
    "content": "\nThe following config declares the deploy job that run on all branches. The job will either release:\na new latest version from baseBrancha canary build from a pull request (if your package manager plugin implements them)\n.travis.yml\nlanguage: node_js\nnode_js: \"10\"\n\ngit:\n  depth: false\n\nscript:\n  - yarn lint\n  - yarn test\n  - yarn build\n\ndeploy:\n  - provider: script\n    script: if [ \"$GH_TOKEN\" != \"false\" ];then npx auto shipit; fi;\n    skip-cleanup: true\n    on:\n      all_branches: true\nlanguage: node_js\nnode_js: \"10\"\n\ngit:\n  depth: false\n\nscript:\n  - yarn lint\n  - yarn test\n  - yarn build\n\ndeploy:\n  - provider: script\n    script: if [ \"$GH_TOKEN\" != \"false\" ];then npx auto shipit; fi;\n    skip-cleanup: true\n    on:\n      all_branches: true\n"
  },
  {
    "path": [
      "Continuous Integration",
      "Travis CI",
      "Troubleshooting"
    ],
    "url": "docs/build-platforms/travis#troubleshooting",
    "content": "\nIf you are having problems make sure you have done the following:\nGH_TOKEN is setAny other secrets for plugins are set (Ex; NPM_TOKEN with the NPM plugin)"
  },
  {
    "path": [
      "Continuous Integration",
      "Travis CI",
      "Troubleshooting",
      "Detached Head (Monorepo)"
    ],
    "url": "docs/build-platforms/travis#detached-head-monorepo",
    "content": "\nSome plugins might use tools that require you to be on a branch.\nThe default setup for travis leaves you in a \"Detached Head\" state, meaning the git HEAD pointer is not on a branch.\nTo fix this add the following lines to your .travis.yml\nbefore_deploy:\n  - if [ \"$TRAVIS_BRANCH\" == \"main\" ];then\n    git checkout main;\n    fi;\nbefore_deploy:\n  - if [ \"$TRAVIS_BRANCH\" == \"main\" ];then\n    git checkout main;\n    fi;\n\nThis code will ensure that your git HEAD is on baseBranch when creating a new release."
  },
  {
    "path": [
      "Continuous Integration",
      "Travis CI",
      "Troubleshooting",
      "Canary Deploy Failing on Forks"
    ],
    "url": "docs/build-platforms/travis#canary-deploy-failing-on-forks",
    "content": "\nBy default Travis will not pass secrets to forks.\nBecause of this canaries releases will fail.\nYou can either:\nPass secrets to forks (insecure)Only run shipit if secrets are available (recommended, in above config)"
  },
  {
    "path": [
      "Continuous Integration",
      "Travis CI",
      "Examples"
    ],
    "url": "docs/build-platforms/travis#examples",
    "content": "\nrelay-compiler-language-typescript"
  },
  {
    "path": [
      "Configuration",
      "auto Configuration File"
    ],
    "url": "docs/configuration/autorc",
    "content": "\nauto uses cosmiconfig to find your config.\nThis means you can define this file a variety of ways.\ncosmiconfig will start at the root of your project and start to search up the directory tree for the following:\nan auto package.json propertya JSON or YAML, extension-less rc file \".autorc\"an \"rc file\" with the extensions .json, .yaml, .yml, .ts or .jsa auto.config.js or auto.config.js CommonJS modulea auto.config.ts TypeScript module"
  },
  {
    "path": [
      "Configuration",
      "auto Configuration File",
      "Initialization"
    ],
    "url": "docs/configuration/autorc#initialization",
    "content": "\nTo interactively create an .autorc use the init command. You can configure most flags and all labels/changelogTitles.\nauto init\nauto init\n"
  },
  {
    "path": [
      "Configuration",
      "auto Configuration File",
      "TypeScript Configuration"
    ],
    "url": "docs/configuration/autorc#typescript-configuration",
    "content": "\nYou can write your auto configuration in a TypeScript file for easier validation\nauto.config.ts:\nimport { AutoRc } from \"auto\";\n\nimport { INpmConfig } from \"@auto-it/npm\";\nimport { IAllContributorsPluginOptions } from \"@auto-it/all-contributors\";\n\nconst npmOptions: INpmConfig = {\n  exact: true,\n  canaryScope: \"@auto-canary\",\n};\n\nconst allContributorsOptions: IAllContributorsPluginOptions = {\n  types: {\n    plugin: \"**/plugin/**/*\",\n    code: [\"**/src/**/*\", \"**/package.json\", \"**/tsconfig.json\"],\n  },\n};\n\n/** Auto configuration */\nexport default function rc(): AutoRc {\n  return {\n    plugins: [\n      \"released\",\n      [\"npm\", npmOptions],\n      [\"all-contributors\", allContributorsOptions],\n    ],\n    labels: [\n      {\n        name: \"blog-post\",\n        changelogTitle: \"📚 Blog Post\",\n        releaseType: \"none\",\n      },\n    ],\n  };\n}\nimport { AutoRc } from \"auto\";\n\nimport { INpmConfig } from \"@auto-it/npm\";\nimport { IAllContributorsPluginOptions } from \"@auto-it/all-contributors\";\n\nconst npmOptions: INpmConfig = {\n  exact: true,\n  canaryScope: \"@auto-canary\",\n};\n\nconst allContributorsOptions: IAllContributorsPluginOptions = {\n  types: {\n    plugin: \"**/plugin/**/*\",\n    code: [\"**/src/**/*\", \"**/package.json\", \"**/tsconfig.json\"],\n  },\n};\n\n/** Auto configuration */\nexport default function rc(): AutoRc {\n  return {\n    plugins: [\n      \"released\",\n      [\"npm\", npmOptions],\n      [\"all-contributors\", allContributorsOptions],\n    ],\n    labels: [\n      {\n        name: \"blog-post\",\n        changelogTitle: \"📚 Blog Post\",\n        releaseType: \"none\",\n      },\n    ],\n  };\n}\n"
  },
  {
    "path": [
      "Configuration",
      "auto Configuration File",
      "Options"
    ],
    "url": "docs/configuration/autorc#options",
    "content": "\nThe following are all of the top level configuration options for auto.\nWhile some of the following options also exist as flags to certain comments,\nit is recommended to set them in an .autorc so your commands are terser and experience consistent."
  },
  {
    "path": [
      "Configuration",
      "auto Configuration File",
      "Options",
      "Only Publish With Release Label"
    ],
    "url": "docs/configuration/autorc#only-publish-with-release-label",
    "content": "\nConfigure the default release behavior.\n{\n  \"onlyPublishWithReleaseLabel\": true\n}\n{\n  \"onlyPublishWithReleaseLabel\": true\n}\n"
  },
  {
    "path": [
      "Configuration",
      "auto Configuration File",
      "Options",
      "Base Branch"
    ],
    "url": "docs/configuration/autorc#base-branch",
    "content": "\nConfigure what your repo considers the base branch.\nDefaults to either main or master.\n{\n  \"baseBranch\": \"trunk\"\n}\n{\n  \"baseBranch\": \"trunk\"\n}\n"
  },
  {
    "path": [
      "Configuration",
      "auto Configuration File",
      "Options",
      "Plugins"
    ],
    "url": "docs/configuration/autorc#plugins",
    "content": "\nIt is useful to specify your plugins in the rc file rather than in all the commands.\n{\n  \"plugins\": [\"npm\", \"../path/to/plugin.js\", \"NPM_PACKAGE_NAME\"]\n}\n{\n  \"plugins\": [\"npm\", \"../path/to/plugin.js\", \"NPM_PACKAGE_NAME\"]\n}\n"
  },
  {
    "path": [
      "Configuration",
      "auto Configuration File",
      "Options",
      "githubApi"
    ],
    "url": "docs/configuration/autorc#githubapi",
    "content": "\nIf you are using enterprise github, auto lets you configure the github API URL that it uses.\n{\n  \"githubApi\": \"https://github.mine.com/api/v3\"\n}\n{\n  \"githubApi\": \"https://github.mine.com/api/v3\"\n}\n"
  },
  {
    "path": [
      "Configuration",
      "auto Configuration File",
      "Options",
      "githubGraphqlApi"
    ],
    "url": "docs/configuration/autorc#githubgraphqlapi",
    "content": "\nThis is used for doing some searches in auto.\nThe default behavior will construct the root API url for GitHub Enterprise.\nIf you are using enterprise github and your company hosts the graphql at some other URL than the githubApi, you can use githubGraphqlApi to set the base path for auto.\n{\n  \"githubGraphqlApi\": \"https://github.mine.com/other/api/\"\n}\n{\n  \"githubGraphqlApi\": \"https://github.mine.com/other/api/\"\n}\n"
  },
  {
    "path": [
      "Configuration",
      "auto Configuration File",
      "Options",
      "author"
    ],
    "url": "docs/configuration/autorc#author",
    "content": "\nThe name and email to use with git.\n{\n  \"author\": \"Joe Schmo <joe@schmo.com>\"\n}\n{\n  \"author\": \"Joe Schmo <joe@schmo.com>\"\n}\n\nor\n{\n  \"author\": {\n    \"name\": \"Joe Schmo\",\n    \"email\": \"joe@schmo.com\"\n  }\n}\n{\n  \"author\": {\n    \"name\": \"Joe Schmo\",\n    \"email\": \"joe@schmo.com\"\n  }\n}\n"
  },
  {
    "path": [
      "Configuration",
      "auto Configuration File",
      "Options",
      "name"
    ],
    "url": "docs/configuration/autorc#name",
    "content": "\nName to use with git.\nNOTE: Will be deprecated in v10\n{\n  \"name\": \"Joe Schmo\"\n}\n{\n  \"name\": \"Joe Schmo\"\n}\n"
  },
  {
    "path": [
      "Configuration",
      "auto Configuration File",
      "Options",
      "email"
    ],
    "url": "docs/configuration/autorc#email",
    "content": "\nEmail to use with git.\nNOTE: Will be deprecated in v10\n{\n  \"email\": \"joe@schmo.com\"\n}\n{\n  \"email\": \"joe@schmo.com\"\n}\n"
  },
  {
    "path": [
      "Configuration",
      "auto Configuration File",
      "Options",
      "noVersionPrefix"
    ],
    "url": "docs/configuration/autorc#noversionprefix",
    "content": "\nDo not make tags or releases with a v prefix.\n{\n  \"noVersionPrefix\": true\n}\n{\n  \"noVersionPrefix\": true\n}\n"
  },
  {
    "path": [
      "Configuration",
      "auto Configuration File",
      "Options",
      "Command Defaults"
    ],
    "url": "docs/configuration/autorc#command-defaults",
    "content": "\nFor some commands you can supply defaults for some options.\nExample: Adding the following to you .autorc will make auto only release pre-releases to GitHub.\n{\n  \"release\": {\n    \"prerelease\": true\n  }\n}\n{\n  \"release\": {\n    \"prerelease\": true\n  }\n}\n\nPlease refer to each command's documentation to see which options are configurable.\n"
  },
  {
    "path": [
      "Configuration",
      "auto Configuration File",
      "Options",
      "Exclusive Options"
    ],
    "url": "docs/configuration/autorc#exclusive-options",
    "content": "\nThe following options can be set exclusively in the .autorc and do not exist as CLI flags."
  },
  {
    "path": [
      "Configuration",
      "auto Configuration File",
      "Options",
      "versionBranches"
    ],
    "url": "docs/configuration/autorc#versionbranches",
    "content": "\nCreate and manage old major releases.\n{\n  \"versionBranches\": true,\n  // or customize the branch prefix\n  \"versionBranches\": \"major-\"\n}\n{\n  \"versionBranches\": true,\n  // or customize the branch prefix\n  \"versionBranches\": \"major-\"\n}\n"
  },
  {
    "path": [
      "Configuration",
      "auto Configuration File",
      "Options",
      "Prerelease Branches"
    ],
    "url": "docs/configuration/autorc#prerelease-branches",
    "content": "\nYou can configure what branches auto treats as prerelease branches.\nBy default only next is treated as a prerelease branch.\nIf you configure prereleaseBranches it will override the default.\n{\n  \"prereleaseBranches\": [\"next\", \"beta\"]\n}\n{\n  \"prereleaseBranches\": [\"next\", \"beta\"]\n}\n"
  },
  {
    "path": [
      "Configuration",
      "auto Configuration File",
      "Options",
      "Labels"
    ],
    "url": "docs/configuration/autorc#labels",
    "content": "\nTo customize your project's labels use the labels section in your .autorc.\n{\n  \"labels\": [\n    { \"releaseType\": \"major\", \"name\": \"Version: Major\" },\n    { \"releaseType\": \"minor\", \"name\": \"Version: Minor\" },\n    { \"releaseType\": \"patch\", \"name\": \"Version: Patch\" },\n    { \"releaseType\": \"skip\", \"name\": \"NO!\" },\n    { \"releaseType\": \"release\", \"name\": \"Autobots, rollout!\" }\n  ]\n}\n{\n  \"labels\": [\n    { \"releaseType\": \"major\", \"name\": \"Version: Major\" },\n    { \"releaseType\": \"minor\", \"name\": \"Version: Minor\" },\n    { \"releaseType\": \"patch\", \"name\": \"Version: Patch\" },\n    { \"releaseType\": \"skip\", \"name\": \"NO!\" },\n    { \"releaseType\": \"release\", \"name\": \"Autobots, rollout!\" }\n  ]\n}\n\nClick here to see the default label configuration[\n  {\n    \"name\": \"major\",\n    \"changelogTitle\": \"💥 Breaking Change\",\n    \"description\": \"Increment the major version when merged\",\n    \"releaseType\": \"major\",\n    \"color\": \"#C5000B\"\n  },\n  {\n    \"name\": \"minor\",\n    \"changelogTitle\": \"🚀 Enhancement\",\n    \"description\": \"Increment the minor version when merged\",\n    \"releaseType\": \"minor\",\n    \"color\": \"#F1A60E\"\n  },\n  {\n    \"name\": \"patch\",\n    \"changelogTitle\": \"🐛 Bug Fix\",\n    \"description\": \"Increment the patch version when merged\",\n    \"releaseType\": \"patch\",\n    \"color\": \"#870048\"\n  },\n  {\n    \"name\": \"skip-release\",\n    \"description\": \"Preserve the current version when merged\",\n    \"releaseType\": \"skip\",\n    \"color\": \"#bf5416\"\n  },\n  {\n    \"name\": \"release\",\n    \"description\": \"Create a release when this pr is merged\",\n    \"releaseType\": \"release\",\n    \"color\": \"#007f70\"\n  },\n  {\n    \"name\": \"internal\",\n    \"changelogTitle\": \"🏠 Internal\",\n    \"description\": \"Changes only affect the internal API\",\n    \"releaseType\": \"none\",\n    \"color\": \"#696969\"\n  },\n  {\n    \"name\": \"documentation\",\n    \"changelogTitle\": \"📝 Documentation\",\n    \"description\": \"Changes only affect the documentation\",\n    \"releaseType\": \"none\",\n    \"color\": \"#cfd3d7\"\n  },\n  {\n    \"name\": \"tests\",\n    \"changelogTitle\": \"🧪 Tests\",\n    \"description\": \"Add or improve existing tests\",\n    \"releaseType\": \"none\",\n    \"color\": \"#ffd3cc\"\n  },\n  {\n    \"name\": \"dependencies\",\n    \"changelogTitle\": \"🔩 Dependency Updates\",\n    \"description\": \"Update one or more dependencies version\",\n    \"releaseType\": \"none\",\n    \"color\": \"#8732bc\"\n  },\n  {\n    \"name\": \"performance\",\n    \"changelogTitle\": \"🏎 Performance\",\n    \"description\": \"Improve performance of an existing feature\",\n    \"releaseType\": \"patch\",\n    \"color\": \"#f4b2d8\"\n  }\n]\n[\n  {\n    \"name\": \"major\",\n    \"changelogTitle\": \"💥 Breaking Change\",\n    \"description\": \"Increment the major version when merged\",\n    \"releaseType\": \"major\",\n    \"color\": \"#C5000B\"\n  },\n  {\n    \"name\": \"minor\",\n    \"changelogTitle\": \"🚀 Enhancement\",\n    \"description\": \"Increment the minor version when merged\",\n    \"releaseType\": \"minor\",\n    \"color\": \"#F1A60E\"\n  },\n  {\n    \"name\": \"patch\",\n    \"changelogTitle\": \"🐛 Bug Fix\",\n    \"description\": \"Increment the patch version when merged\",\n    \"releaseType\": \"patch\",\n    \"color\": \"#870048\"\n  },\n  {\n    \"name\": \"skip-release\",\n    \"description\": \"Preserve the current version when merged\",\n    \"releaseType\": \"skip\",\n    \"color\": \"#bf5416\"\n  },\n  {\n    \"name\": \"release\",\n    \"description\": \"Create a release when this pr is merged\",\n    \"releaseType\": \"release\",\n    \"color\": \"#007f70\"\n  },\n  {\n    \"name\": \"internal\",\n    \"changelogTitle\": \"🏠 Internal\",\n    \"description\": \"Changes only affect the internal API\",\n    \"releaseType\": \"none\",\n    \"color\": \"#696969\"\n  },\n  {\n    \"name\": \"documentation\",\n    \"changelogTitle\": \"📝 Documentation\",\n    \"description\": \"Changes only affect the documentation\",\n    \"releaseType\": \"none\",\n    \"color\": \"#cfd3d7\"\n  },\n  {\n    \"name\": \"tests\",\n    \"changelogTitle\": \"🧪 Tests\",\n    \"description\": \"Add or improve existing tests\",\n    \"releaseType\": \"none\",\n    \"color\": \"#ffd3cc\"\n  },\n  {\n    \"name\": \"dependencies\",\n    \"changelogTitle\": \"🔩 Dependency Updates\",\n    \"description\": \"Update one or more dependencies version\",\n    \"releaseType\": \"none\",\n    \"color\": \"#8732bc\"\n  },\n  {\n    \"name\": \"performance\",\n    \"changelogTitle\": \"🏎 Performance\",\n    \"description\": \"Improve performance of an existing feature\",\n    \"releaseType\": \"patch\",\n    \"color\": \"#f4b2d8\"\n  }\n]\n"
  },
  {
    "path": [
      "Configuration",
      "auto Configuration File",
      "Options",
      "Labels",
      "Overriding default Labels"
    ],
    "url": "docs/configuration/autorc#overriding-default-labels",
    "content": "\nBy default Auto will add the labels you configured to the list of default labels. If you want to create only the labels you configured and ignore defaults, use noDefaultLabels option:\n{\n  \"noDefaultLabels\": true,\n  \"labels\": [\n    // custom labels\n  ]\n}\n{\n  \"noDefaultLabels\": true,\n  \"labels\": [\n    // custom labels\n  ]\n}\n"
  },
  {
    "path": [
      "Configuration",
      "auto Configuration File",
      "Options",
      "Labels",
      "Label Customization"
    ],
    "url": "docs/configuration/autorc#label-customization",
    "content": "\nYou can customize everything about a label\nname - The label text used for the label. If omitted defaults to the key valuereleaseType - The type of release to trigger (major, minor, patch, skip, release, or none)overwrite - Overwrite the default label(s) associated with the releaseType. (default: false)changelogTitle - The title to use in the changelogdescription - The description to use when creating the labeldefault - Marks this label as the default label for unlabelled PRs (patch is the default \"default label\")color - The color of the label. Can be specified as a string in any of these ways. If not specified the color is random\n{\n  \"labels\": [\n    {\n      \"name\": \"Version: Major\",\n      \"changelogTitle\": \"The API has changed:\",\n      \"description\": \"Add this label to a PR to create a major release\",\n      \"color\": \"blue\",\n      \"releaseType\": \"major\"\n    }\n  ]\n}\n{\n  \"labels\": [\n    {\n      \"name\": \"Version: Major\",\n      \"changelogTitle\": \"The API has changed:\",\n      \"description\": \"Add this label to a PR to create a major release\",\n      \"color\": \"blue\",\n      \"releaseType\": \"major\"\n    }\n  ]\n}\n"
  },
  {
    "path": [
      "Configuration",
      "auto Configuration File",
      "Options",
      "Labels",
      "Release Type: skip"
    ],
    "url": "docs/configuration/autorc#release-type-skip",
    "content": "\nA label with the skip release type will not create a release when merged even when paired with other labels.\n{\n  \"labels\": [\n    {\n      \"name\": \"infra\",\n      \"releaseType\": \"skip\"\n    }\n  ]\n}\n{\n  \"labels\": [\n    {\n      \"name\": \"infra\",\n      \"releaseType\": \"skip\"\n    }\n  ]\n}\n"
  },
  {
    "path": [
      "Configuration",
      "auto Configuration File",
      "Options",
      "Labels",
      "Release Type: none"
    ],
    "url": "docs/configuration/autorc#release-type-none",
    "content": "\nA label with the none release type will not create a release when merged.\nIf paired with a SEMVER label, the release is not skipped.\n{\n  \"labels\": [\n    {\n      \"name\": \"documentation\",\n      \"releaseType\": \"none\"\n    }\n  ]\n}\n{\n  \"labels\": [\n    {\n      \"name\": \"documentation\",\n      \"releaseType\": \"none\"\n    }\n  ]\n}\n"
  },
  {
    "path": [
      "Configuration",
      "auto Configuration File",
      "Options",
      "Labels",
      "Changelog Titles"
    ],
    "url": "docs/configuration/autorc#changelog-titles",
    "content": "\nEach PR included in the release will be assigned to a label section based upon the matching label with the highest releaseType that has a changelogTitle.\nPriority order of releaseType from highest to lowest is: major, minor, patch, and then all othersIf a PR has multiple labels of the same releaseType, then the PR is assigned based upon the label that is assigned first in the config\nBy default auto will create sections in the changelog for the following labels:\nmajorminorpatchinternaldocumentation\nFor example:\nUsing the default config, if a given PR has the labels minor and internal, then it will be included in the minor label sectionUsing the default config, if a given PR has the labels documentation and internal, then it will be included in the internal label section"
  },
  {
    "path": [
      "Configuration",
      "auto Configuration File",
      "Options",
      "Labels",
      "Changelog Titles",
      "Updating Default Label Changelog Titles"
    ],
    "url": "docs/configuration/autorc#updating-default-label-changelog-titles",
    "content": "\nTo customize the title for the section in the changelog you can\n{\n  \"labels\": [\n    {\n      \"name\": \"documentation\",\n      \"changelogTitle\": \"Docz\"\n    }\n  ]\n}\n{\n  \"labels\": [\n    {\n      \"name\": \"documentation\",\n      \"changelogTitle\": \"Docz\"\n    }\n  ]\n}\n"
  },
  {
    "path": [
      "Configuration",
      "auto Configuration File",
      "Options",
      "Labels",
      "Changelog Titles",
      "Adding Additional Changelog Title Sections"
    ],
    "url": "docs/configuration/autorc#adding-additional-changelog-title-sections",
    "content": "\nIf you want more sections in your changelog to further detail the change-set you can\nuse the labels section to add more. Any label in the label section with a changelogTitle\nwill become a special section in your changelog.\nThe following adds a typescript label to the project that we can use to denote changes\nrelated to a TypeScript re-write.\n{\n  \"labels\": [\n    {\n      \"name\": \"typescript\",\n      \"changelogTitle\": \"TypeScript Rewrite\"\n    }\n  ]\n}\n{\n  \"labels\": [\n    {\n      \"name\": \"typescript\",\n      \"changelogTitle\": \"TypeScript Rewrite\"\n    }\n  ]\n}\n"
  },
  {
    "path": [
      "Configuration",
      "auto Configuration File",
      "Options",
      "Labels",
      "Removing Default Label Changelog Title Sections"
    ],
    "url": "docs/configuration/autorc#removing-default-label-changelog-title-sections",
    "content": "\nYou can remove the existing default label sections by adding a custom overwrite label with the same releaseType.\nThe following removes the default internal and documentation label sections:\n{\n  \"labels\": [\n    {\n      \"name\": \"Custom Doc Label\",\n      \"changelogTitle\": \"Docz\",\n      \"releaseType\": \"none\",\n      \"overwrite\": true\n    }\n  ]\n}\n{\n  \"labels\": [\n    {\n      \"name\": \"Custom Doc Label\",\n      \"changelogTitle\": \"Docz\",\n      \"releaseType\": \"none\",\n      \"overwrite\": true\n    }\n  ]\n}\n"
  },
  {
    "path": [
      "Configuration",
      "auto Configuration File",
      "Extending"
    ],
    "url": "docs/configuration/autorc#extending",
    "content": "\nIf you want to share your auto configuration between projects you can use the extends property.\nThis property will load from a module's package.json or from a custom path.\nIt's expected that the extended configuration be under the auto key in the package.json file.\nAuto can load extends configs in the following ways:\nfrom a path ./path/to/config (this file must be in JSON format)from a scoped package @YOUR_SCOPE/auto-config (under the auto key in the package.json)from a package auto-config-YOUR_NAMEfrom a url https://yourdomain.com/auto-config.json (must return the content type application/json)"
  },
  {
    "path": [
      "Configuration",
      "auto Configuration File",
      "Extending",
      "Formats"
    ],
    "url": "docs/configuration/autorc#formats",
    "content": "\n{\n  \"extends\": \"@YOUR_SCOPE\"\n}\n{\n  \"extends\": \"@YOUR_SCOPE\"\n}\n\nWill use the package @YOUR_SCOPE/auto-config\n{\n  \"extends\": \"joe\"\n}\n{\n  \"extends\": \"joe\"\n}\n\nWill use the package auto-config-joe\n⚠️ If extending from a config package make sure it's a dependency of your project\nIf you're extending from a local file it can be any file in JSON format or a package.json file.\n{\n  \"extends\": \"./path/to/config.json\"\n}\n{\n  \"extends\": \"./path/to/config.json\"\n}\n\n{\n  \"extends\": \"./path/to/other/package.json\"\n}\n{\n  \"extends\": \"./path/to/other/package.json\"\n}\n"
  },
  {
    "path": [
      "Configuration",
      "auto Configuration File",
      "Extending",
      "Custom Plugins"
    ],
    "url": "docs/configuration/autorc#custom-plugins",
    "content": "\nAn extends configuration can include custom plugins in the NPM package.\nThis is useful if you have a shared plugin that doesn't necessarily need to be published as it's own package.\nNOTE: This does not work for auto configs stored in a url.\nTo include custom plugins just use a relative path in the extended configuration/\npackage.json:\n{\n  \"auto\": {\n    \"plugins\": [\"./plugins/some-plugin.js\"]\n  }\n}\n{\n  \"auto\": {\n    \"plugins\": [\"./plugins/some-plugin.js\"]\n  }\n}\n"
  },
  {
    "path": [
      "Configuration",
      "Non-npm Usage"
    ],
    "url": "docs/configuration/non-npm",
    "content": "\nIf you're on some platform other than npm it doesn't make sense to download auto through npm.\nFor these situations we package auto for all major operating systems (linux, osx, windows)."
  },
  {
    "path": [
      "Configuration",
      "Non-npm Usage",
      "Installation"
    ],
    "url": "docs/configuration/non-npm#installation",
    "content": "\nSimply download the appropriate version for your operating system and make it executable.\n# Download a platform specific version of auto\ncurl -vkL -o - https://github.com/intuit/auto/releases/download/v10.26.1/auto-linux.gz | gunzip > ~/auto\n# Make auto executable\nchmod a+x ~/auto\n# Download a platform specific version of auto\ncurl -vkL -o - https://github.com/intuit/auto/releases/download/v10.26.1/auto-linux.gz | gunzip > ~/auto\n# Make auto executable\nchmod a+x ~/auto\n\nThis executable contains all of the official auto plugins so you do not have to download anything extra.\nThis version of auto uses the git-tag plugins as the default instead of npm.\nIf you specify any plugins this will be overridden."
  },
  {
    "path": [
      "Configuration",
      "Non-npm Usage",
      "Installation",
      "Installation via brew (OSX)"
    ],
    "url": "docs/configuration/non-npm#installation-via-brew-osx",
    "content": "\nIf you are on OSX you can install auto with brew.\nbrew tap intuit/auto https://github.com/intuit/auto\nbrew install auto\nbrew tap intuit/auto https://github.com/intuit/auto\nbrew install auto\n"
  },
  {
    "path": [
      "Configuration",
      "Non-npm Usage",
      "Configuration"
    ],
    "url": "docs/configuration/non-npm#configuration",
    "content": "\nTo configure auto to work with your project you will need to do two things\nCreate and configure a GH_TOKEN environment variableCreate an .autorc for your project"
  },
  {
    "path": [
      "Configuration",
      "Non-npm Usage",
      "Configuration",
      "Making an .autorc"
    ],
    "url": "docs/configuration/non-npm#making-an-autorc",
    "content": "\nUsing auto with any other package manager than npm requires that you create an .autorc at the root of your project.\n.autorc - No plugins, shipit doesn't work. Enables advanced setup{\n  \"author\": \"Andrew Lisowski <lisowski54@gmail.com>\",\n  \"plugins\": []\n}\n{\n  \"author\": \"Andrew Lisowski <lisowski54@gmail.com>\",\n  \"plugins\": []\n}\n.autorc - git-tag plugin compatible with any platform. Enables shipit usage{\n  \"author\": \"Andrew Lisowski <lisowski54@gmail.com>\",\n  \"plugins\": [\"git-tag\"]\n}\n{\n  \"author\": \"Andrew Lisowski <lisowski54@gmail.com>\",\n  \"plugins\": [\"git-tag\"]\n}\n.autorc - With package manager plugin. shipit works, some configuration picked up from package manager package definition files. In the following repo, owner, and author are picked up from the pom.xml{\n  \"plugins\": [\"maven\"]\n}\n{\n  \"plugins\": [\"maven\"]\n}\n"
  },
  {
    "path": [
      "Configuration",
      "Non-npm Usage",
      "Configuration",
      "Making an .autorc",
      "Local Plugins"
    ],
    "url": "docs/configuration/non-npm#local-plugins",
    "content": "\nOne way to use unofficial plugins in a non-javascript project is to have a directory committed to your project where you store them.\nYou could:\nWrite your own custom plugins and store them in hereCopy a plugin from the internet\n.autorc:\n{\n  \"plugins\": [\"./plugins/custom-plugin.js\"]\n}\n{\n  \"plugins\": [\"./plugins/custom-plugin.js\"]\n}\n"
  },
  {
    "path": [
      "Configuration",
      "Non-npm Usage",
      "Configuration",
      "Making an .autorc",
      "Hosted Plugins"
    ],
    "url": "docs/configuration/non-npm#hosted-plugins",
    "content": "\nIf you want to share your custom plugins between projects then you can host them on some SCM (ex: GitHub).\nA plugin just needs to consist of an index.js that implements your plugin. (or it could be as complex as any NPM package)\nEdit your CI build to download these plugins when building.\nmkdir plugins\ngit clone https://github.com/me/custom-plugin plugins/custom-plugin\nmkdir plugins\ngit clone https://github.com/me/custom-plugin plugins/custom-plugin\n\n.autorc:\n{\n  \"plugins\": [\"./plugins/custom-plugin\"]\n}\n{\n  \"plugins\": [\"./plugins/custom-plugin\"]\n}\n"
  },
  {
    "path": [
      "Configuration",
      "Non-npm Usage",
      "Configuration",
      "Making an .autorc",
      "NPM Plugins"
    ],
    "url": "docs/configuration/non-npm#npm-plugins",
    "content": "\nIf distributed via NPM you could install those plugins globally through npm:\nnpm i -g auto-plugin-my-custom-plugin\nnpm i -g auto-plugin-my-custom-plugin\n\n.autorc:\n{\n  \"plugins\": [\"my-custom-plugin\"]\n}\n{\n  \"plugins\": [\"my-custom-plugin\"]\n}\n"
  },
  {
    "path": [
      "Configuration",
      "Non-npm Usage",
      "Usage"
    ],
    "url": "docs/configuration/non-npm#usage",
    "content": "\nNow that you have auto all set up you can use all of it's commands!\n~/auto shipit\n~/auto shipit\n\nℹ️ Tip: Using auto locally with an .env file is a great experience. See how here."
  },
  {
    "path": [
      "Configuration",
      "Non-npm Usage",
      "Plugins"
    ],
    "url": "docs/configuration/non-npm#plugins",
    "content": "\nAs stated above, all of the official plugins (the ones included in this repo/docs) are included in the binary version of auto.\nHowever you might want to use an unofficial plugin or even write your own."
  },
  {
    "path": [
      "Configuration",
      "Plugins"
    ],
    "url": "docs/configuration/plugins",
    "content": "\nauto uses the package tapable to expose a plugin system. Go here to learn how to write one!"
  },
  {
    "path": [
      "Configuration",
      "Plugins",
      "Using Plugins"
    ],
    "url": "docs/configuration/plugins#using-plugins",
    "content": "\nTo use a plugin you can either supply the plugin via a CLI arg or in your .autorc.\n⚠️ Specifying a plugin overrides the defaults."
  },
  {
    "path": [
      "Configuration",
      "Plugins",
      "Using Plugins",
      "Defaults"
    ],
    "url": "docs/configuration/plugins#defaults",
    "content": "\nIf you don't configure plugins in your .autorc configuration file auto will use a default package manager plugin.\nInstalled through npm => uses npmInstalled through executable => uses git-tag\nFor the majority of \"package manager\" plugins you should only use one at a time.\nUsing multiple will lead to undesired results."
  },
  {
    "path": [
      "Configuration",
      "Plugins",
      "Using Plugins",
      "No Plugins"
    ],
    "url": "docs/configuration/plugins#no-plugins",
    "content": "\nIf you don't want to include the default plugins, you can supply an empty array in the .autorc configuration file like the following:\n{\n  \"plugins\": []\n}\n{\n  \"plugins\": []\n}\n"
  },
  {
    "path": [
      "Configuration",
      "Plugins",
      "Plugin Declaration"
    ],
    "url": "docs/configuration/plugins#plugin-declaration",
    "content": "\nThere are three ways to name and use a plugin."
  },
  {
    "path": [
      "Configuration",
      "Plugins",
      "Plugin Declaration",
      "Official Plugins"
    ],
    "url": "docs/configuration/plugins#official-plugins",
    "content": "\nTo use an official plugin all you have to do is supply the name.\n{\n  \"plugins\": [\n    \"npm\",\n    // or the full name\n    \"@auto-it/npm\"\n  ]\n}\n{\n  \"plugins\": [\n    \"npm\",\n    // or the full name\n    \"@auto-it/npm\"\n  ]\n}\n"
  },
  {
    "path": [
      "Configuration",
      "Plugins",
      "Plugin Declaration",
      "npm package"
    ],
    "url": "docs/configuration/plugins#npm-package",
    "content": "\nUnofficial plugins pulled from NPM should be named in one of the following formats:\nauto-plugin-PLUGIN_NAME@my-scope/auto-plugin-PLUGIN_NAME\nYou use them in your .autorc by:\nprovide the full package namewhen named like auto-plugin-PLUGIN_NAME just the PLUGIN_NAME.\n{\n  \"plugins\": [\n    \"my-cool-plugin\",\n    // or\n    \"auto-plugin-my-cool-plugin\",\n    // on a scope\n    \"@my-scope/auto-plugin-my-cool-plugin\"\n  ]\n}\n{\n  \"plugins\": [\n    \"my-cool-plugin\",\n    // or\n    \"auto-plugin-my-cool-plugin\",\n    // on a scope\n    \"@my-scope/auto-plugin-my-cool-plugin\"\n  ]\n}\n"
  },
  {
    "path": [
      "Configuration",
      "Plugins",
      "Plugin Declaration",
      "Local Plugin"
    ],
    "url": "docs/configuration/plugins#local-plugin",
    "content": "\nOr if you have a plugin locally supply the path.\n{\n  \"plugins\": [\"../path/to/plugin.js\"]\n}\n{\n  \"plugins\": [\"../path/to/plugin.js\"]\n}\n"
  },
  {
    "path": [
      "Configuration",
      "Plugins",
      "Plugin Configuration"
    ],
    "url": "docs/configuration/plugins#plugin-configuration",
    "content": "\nTo provide plugin specific config change the following:\n{\n  \"plugins\": [\"chrome\"]\n}\n{\n  \"plugins\": [\"chrome\"]\n}\n\nTo this:\n{\n  \"plugins\": [\n    [\"chrome\", { \"extensionId\": \"1234\", \"build\": \"my-compiled-extension.zip\" }]\n  ]\n}\n{\n  \"plugins\": [\n    [\"chrome\", { \"extensionId\": \"1234\", \"build\": \"my-compiled-extension.zip\" }]\n  ]\n}\n"
  },
  {
    "path": [
      "Configuration",
      "Troubleshooting"
    ],
    "url": "docs/configuration/troubleshooting",
    "content": ""
  },
  {
    "path": [
      "Configuration",
      "Troubleshooting",
      "Error: Can't find a GitHub token to use"
    ],
    "url": "docs/configuration/troubleshooting#error-cant-find-a-github-token-to-use",
    "content": "\nYou must set a GH_TOKEN for auto to work. If you publish to npm make sure to add your NPM_TOKEN while you're at it as well."
  },
  {
    "path": [
      "Configuration",
      "Troubleshooting",
      "Working directory not clean"
    ],
    "url": "docs/configuration/troubleshooting#working-directory-not-clean",
    "content": "\nTo version and publish you cannot have any changes in the git repo during publish. This means that if you build some files before release that aren't git-ignored auto will fail to continue. To fix this either add those dist files to your .gitignore or commit them somehow before the release."
  },
  {
    "path": [
      "Configuration",
      "Troubleshooting",
      "You cannot publish over the previously published versions"
    ],
    "url": "docs/configuration/troubleshooting#you-cannot-publish-over-the-previously-published-versions",
    "content": "\nIf you've encountered any of these errors you'll probably run into this problem. If the whole release process doesn't complete you can end up in a state when auto published the new version, but doesn't push that back to github. To fix this just bump the version number to the \"previously published version\"."
  },
  {
    "path": [
      "Configuration",
      "Troubleshooting",
      "How do I auto a fork of another repo?"
    ],
    "url": "docs/configuration/troubleshooting#how-do-i-auto-a-fork-of-another-repo",
    "content": "\nIf auto doesn't find a last release it will default to the first commit for version calculation (and a log of other things). If you have forked a repo, you fork all the merge commit messages as well. This confuses auto since it will look for those pull requests in your fork and not the main one.\nTo remedy this first tag your first commit in the fork with your first version. If the tags from the original repo are still in your repo you should just bump that version. This will let auto ignore all the old merge commits.\n⚠️ You must also match this new tag version in your package.json\n# Set head to last release and tag it with 2.10.1\ngit tag v2.10.1\n# Set head to last release and tag it with 2.10.1\ngit tag v2.10.1\n\nThen on GitHub go to your project, click release, then draft a new release. Select the tag you just published and publish release. Now auto will be able to use the correct version and git log!"
  },
  {
    "path": [
      "Functionality Plugins",
      "All Contributors Plugin"
    ],
    "url": "docs/generated/all-contributors",
    "content": "\nAutomatically add contributors as changelogs are produced.\nThis plugin maps one of the contribution types to a glob or array of globs.\nOut of the box the plugin will only detect the following contribution types:\n📖 doc - Edits to any README ['**/*.mdx', '**/*.md', '**/docs/**/*', '**/documentation/**/*']💡 example - Edits to ['**/*.stories*', '**/*.story.*']🚇 infra - Edits to ['**/.circle/**/*', '**/.github/**/*', '**/travis.yml'],⚠️ test - Edits to ['**/*.test.*']💻 code - Edits to ['**/src/**/*', '**/lib/**/*', '**/package.json', '**/tsconfig.json']"
  },
  {
    "path": [
      "Functionality Plugins",
      "All Contributors Plugin",
      "Installation"
    ],
    "url": "docs/generated/all-contributors#installation",
    "content": "\nThis plugin is not included with the auto CLI installed via NPM. To install:\nnpm i --save-dev @auto-it/all-contributors\n# or\nyarn add -D @auto-it/all-contributors\nnpm i --save-dev @auto-it/all-contributors\n# or\nyarn add -D @auto-it/all-contributors\n"
  },
  {
    "path": [
      "Functionality Plugins",
      "All Contributors Plugin",
      "Prerequisites"
    ],
    "url": "docs/generated/all-contributors#prerequisites",
    "content": "\nFor this plugin to work your project needs to have initialized an all-contributors RC file.\nnpx all-contributors init\nnpx all-contributors init\n"
  },
  {
    "path": [
      "Functionality Plugins",
      "All Contributors Plugin",
      "Usage"
    ],
    "url": "docs/generated/all-contributors#usage",
    "content": "\n{\n  \"plugins\": [\"all-contributors\"]\n}\n{\n  \"plugins\": [\"all-contributors\"]\n}\n"
  },
  {
    "path": [
      "Functionality Plugins",
      "All Contributors Plugin",
      "Usage",
      "Configure Contribution Type Matching"
    ],
    "url": "docs/generated/all-contributors#configure-contribution-type-matching",
    "content": "\nYou use any of the contribution types.\nIf you configure an pre-configured contribution type the arrays are not merged, it is overridden.\nauto.rc\n{\n  \"plugins\": [\n    [\n      \"all-contributors\",\n      {\n        \"types\": {\n          \"plugin\": \"**/plugin/**/*\",\n          \"example\": [\"**/*.stories.*\", \"**/*.examples.*\", \"**/*.snippet.*\"]\n        }\n      }\n    ]\n  ]\n}\n{\n  \"plugins\": [\n    [\n      \"all-contributors\",\n      {\n        \"types\": {\n          \"plugin\": \"**/plugin/**/*\",\n          \"example\": [\"**/*.stories.*\", \"**/*.examples.*\", \"**/*.snippet.*\"]\n        }\n      }\n    ]\n  ]\n}\n"
  },
  {
    "path": [
      "Functionality Plugins",
      "All Contributors Plugin",
      "Usage",
      "Adding Non-Code Contributions"
    ],
    "url": "docs/generated/all-contributors#adding-non-code-contributions",
    "content": "\nSometimes you worked with a person that didn't touch the code personally so this plugin would never attribute them with any contributions.\nSince these contributions cannot be automated you can instead just list out another contributor's contributions directly in the PR.\nThese contributors will also be added to all changelogs that auto outputs.\nAdd the following to a PR body and auto will try to parse it and add contributors from it.\n# Contributions\n\n- @some_guy - design, doc\n# Contributions\n\n- @some_guy - design, doc\n\nTo ensure you are doing it right auto will comment on the PR with the people + contributions you are manually adding."
  },
  {
    "path": [
      "Functionality Plugins",
      "All Contributors Plugin",
      "Usage",
      "Exclude Users"
    ],
    "url": "docs/generated/all-contributors#exclude-users",
    "content": "\nUseful for excluding bots from getting into your contributors.\nauto.rc\n{\n  \"plugins\": [\n    [\n      \"all-contributors\",\n      {\n        \"exclude\": [\"dependabot\", \"ci-services\"]\n      }\n    ]\n  ]\n}\n{\n  \"plugins\": [\n    [\n      \"all-contributors\",\n      {\n        \"exclude\": [\"dependabot\", \"ci-services\"]\n      }\n    ]\n  ]\n}\n"
  },
  {
    "path": [
      "Functionality Plugins",
      "All Contributors Plugin",
      "Usage",
      "Sub-Package Contributors list"
    ],
    "url": "docs/generated/all-contributors#sub-package-contributors-list",
    "content": "\nMaintain contributors lists for sub-packages in a monorepo setup (lerna/yarn).\nAll you need to do is initialize each sub-package you want contributors tracked in with an .all-contributorsrc. If no rc file is found nothing will happen for that package. Any non-code contribution listed in the PR body will also be added to the sub-package contributors list.\ncd packages/your-package\nnpx all-contributors init\ncd packages/your-package\nnpx all-contributors init\n\nℹ️ Tip: If you only want 1 commit for new contributions set commit to false in all of your .all-contributorsrc. Otherwise a commit will be made for each package's contributor update."
  },
  {
    "path": [
      "Package Manager Plugins",
      "Brew Plugin"
    ],
    "url": "docs/generated/brew",
    "content": "\nAutomate the creation of Homebrew formulae.\nThis plugin can be use with any other package manager plugin.\nNOTE: This plugin does not work in lerna monorepos that use independent versioning."
  },
  {
    "path": [
      "Package Manager Plugins",
      "Brew Plugin",
      "Installation"
    ],
    "url": "docs/generated/brew#installation",
    "content": "\nThis plugin is not included with the auto CLI installed via NPM. To install:\nnpm i --save-dev @auto-it/brew\n# or\nyarn add -D @auto-it/brew\nnpm i --save-dev @auto-it/brew\n# or\nyarn add -D @auto-it/brew\n"
  },
  {
    "path": [
      "Package Manager Plugins",
      "Brew Plugin",
      "Usage"
    ],
    "url": "docs/generated/brew#usage",
    "content": "\nTo use this plugin you will need to add the required configuration and a template file.\nexecutable - REQUIRED: The executable to create a formula forname - REQUIRED: The name of the formula to createformula - A path to the formula template. Default is './formula-template.rb'\n{\n  \"plugins\": [\n    [\n      \"brew\",\n      {\n        \"executable\": \"path/to/some/executable\",\n        \"name\": \"name-of-formula\",\n        \"formula\": \"path/to/formula/template\"\n      }\n    ]\n  ]\n}\n{\n  \"plugins\": [\n    [\n      \"brew\",\n      {\n        \"executable\": \"path/to/some/executable\",\n        \"name\": \"name-of-formula\",\n        \"formula\": \"path/to/formula/template\"\n      }\n    ]\n  ]\n}\n\nCreate a template name ./formula-template.rb at the root of the project (or use the formula option to customize the location)/\nThe template file must be a valid homebrew ruby file.\nauto will replace the following tokens in the template file:\n$VERSION - The version being published$SHA - The sha of the executable being included in the formula\nHere is the template auto uses to publish it's own brew formula:\nclass Auto < Formula\n  desc \"Generate releases based on semantic version labels on pull requests.\"\n  homepage \"https://intuit.github.io/auto/home.html\"\n  url \"https://github.com/intuit/auto/releases/download/$VERSION/auto-macos.gz\"\n  version \"$VERSION\"\n  sha256 \"$SHA\"\n\n  def install\n    libexec.install Dir[\"*\"]\n    bin.install libexec/\"auto-macos\"\n    mv bin/\"auto-macos\", bin/\"auto\"\n  end\n\n  test do\n    system bin/\"auto\", \"--version\"\n  end\nend\nclass Auto < Formula\n  desc \"Generate releases based on semantic version labels on pull requests.\"\n  homepage \"https://intuit.github.io/auto/home.html\"\n  url \"https://github.com/intuit/auto/releases/download/$VERSION/auto-macos.gz\"\n  version \"$VERSION\"\n  sha256 \"$SHA\"\n\n  def install\n    libexec.install Dir[\"*\"]\n    bin.install libexec/\"auto-macos\"\n    mv bin/\"auto-macos\", bin/\"auto\"\n  end\n\n  test do\n    system bin/\"auto\", \"--version\"\n  end\nend\n"
  },
  {
    "path": [
      "Package Manager Plugins",
      "Brew Plugin",
      "Usage",
      "Multiple Formulae"
    ],
    "url": "docs/generated/brew#multiple-formulae",
    "content": "\nYou can also use this to create multiple brew formulae.\n{\n  \"plugins\": [\n    [\n      \"brew\",\n      [\n        {\n          \"executable\": \"path/to/some/executable\",\n          \"name\": \"name-of-formula\",\n          \"formula\": \"path/to/formula/template\"\n        },\n        {\n          \"executable\": \"path/to/another/executable\",\n          \"name\": \"another-formula\",\n          \"formula\": \"path/to/formula/another\"\n        }\n      ]\n    ]\n  ]\n}\n{\n  \"plugins\": [\n    [\n      \"brew\",\n      [\n        {\n          \"executable\": \"path/to/some/executable\",\n          \"name\": \"name-of-formula\",\n          \"formula\": \"path/to/formula/template\"\n        },\n        {\n          \"executable\": \"path/to/another/executable\",\n          \"name\": \"another-formula\",\n          \"formula\": \"path/to/formula/another\"\n        }\n      ]\n    ]\n  ]\n}\n"
  },
  {
    "path": [
      "Publishing",
      "canary"
    ],
    "url": "docs/generated/canary",
    "content": "\nMake a canary release of the project. Useful on PRs. If ran locally, canary will release a canary version for your current git HEAD. This is ran automatically from \"shipit\".\nIn PR: 1.2.3-canary.123.0 + add version to PR bodyLocally: 1.2.3-canary.1810cfd"
  },
  {
    "path": [
      "Publishing",
      "canary",
      "Options"
    ],
    "url": "docs/generated/canary#options",
    "content": "\nFlagTypeDescription--dry-run, -dBooleanReport what command will do but do not actually do anything--prNumberPR number to use to create the canary version. Detected in CI env--buildStringBuild number to use to create the canary version. Detected in CI env--targetpr-body | comment | statusHow the canary version should be attached to a PR--message, -mStringMessage to comment on PR with. Defaults to 'Published PR with canary version: %v'. Pass false to disable the comment--forceBooleanForce a next release, even if the last commit is marked to skip the release--quiet, -qBooleanPrint only the result of the command"
  },
  {
    "path": [
      "Publishing",
      "canary",
      "Examples"
    ],
    "url": "docs/generated/canary#examples",
    "content": "\nauto canary\nauto canary\n\nauto canary --force\nauto canary --force\n\nauto canary --pr 123 --build 5\nauto canary --pr 123 --build 5\n\nauto canary --message \"Install PR version: `yarn add -D my-project@%v`\"\nauto canary --message \"Install PR version: `yarn add -D my-project@%v`\"\n\nauto canary --message false\nauto canary --message false\n"
  },
  {
    "path": [
      "Publishing",
      "canary",
      "Configurable Options"
    ],
    "url": "docs/generated/canary#configurable-options",
    "content": "\nYou can configure some of the options for the canary command in the .autorc.\ntargetmessageforce\nExample .autorc:\n{\n  \"canary\": {\n    \"target\": \"pr-body\",\n    \"message\": \"string\",\n    \"force\": true\n  }\n}\n{\n  \"canary\": {\n    \"target\": \"pr-body\",\n    \"message\": \"string\",\n    \"force\": true\n  }\n}\n"
  },
  {
    "path": [
      "Publishing",
      "changelog"
    ],
    "url": "docs/generated/changelog",
    "content": "\nPrepend release notes to CHANGELOG.md, create one if it doesn't exist, and commit the changes."
  },
  {
    "path": [
      "Publishing",
      "changelog",
      "Options"
    ],
    "url": "docs/generated/changelog#options",
    "content": "\nFlagTypeDescription--dry-run, -dBooleanReport what command will do but do not actually do anything--no-version-prefixBooleanUse the version as the tag without the 'v' prefix. WARNING: some plugins might need extra config to use this option (ex: npm)--nameStringGit name to commit  with. Defaults to package definition for the platform--emailStringGit email to commit with. Defaults to package definition for the platform--fromStringTag to start changelog generation on. Defaults to latest tag.--toStringTag to end changelog generation on. Defaults to HEAD.--titleStringOverride the title used in the addition to the CHANGELOG.md.--message, -mStringMessage to commit the changelog with. Defaults to 'Update CHANGELOG.md [skip ci]'--base-branchStringBranch to treat as the base branch--quiet, -qBooleanPrint only the result of the command"
  },
  {
    "path": [
      "Publishing",
      "changelog",
      "Examples"
    ],
    "url": "docs/generated/changelog#examples",
    "content": "\nGenerate a changelog from the last release to head\nauto changelog\nauto changelog\n\nGenerate a changelog across specific versions\nauto changelog --from v0.20.1 --to v0.21.0\nauto changelog --from v0.20.1 --to v0.21.0\n"
  },
  {
    "path": [
      "Publishing",
      "changelog",
      "Configurable Options"
    ],
    "url": "docs/generated/changelog#configurable-options",
    "content": "\nYou can configure some of the options for the changelog command in the .autorc.\nmessage\nExample .autorc:\n{\n  \"changelog\": {\n    \"message\": \"string\"\n  }\n}\n{\n  \"changelog\": {\n    \"message\": \"string\"\n  }\n}\n\n⚠️ This should be run before you version your project so the CHANGELOG.md changes are committed before the release gets tagged."
  },
  {
    "path": [
      "Publishing",
      "changelog",
      "Changelog Titles"
    ],
    "url": "docs/generated/changelog#changelog-titles",
    "content": "\nYou can customize the changelog titles and even add custom ones. To see configuration go here."
  },
  {
    "path": [
      "Publishing",
      "changelog",
      "Additional Release notes"
    ],
    "url": "docs/generated/changelog#additional-release-notes",
    "content": "\nSometimes a PR title is just not enough to capture what a user should know about that PR. That's why we've included the ability to put extra release notes right in your PRs. All you have to do is add a Release Notes section in your PR.\nTake the following PR body:\n# What Changed\n\nChange `shipit` behavior.\n\n## Release Notes\n\n`auto shipit` will only ship to `latest` on the base branch ([which is configurable]()). If ran locally or from a PR it will create a `canary` release that doesn't interfere with your `latest` release.\n# What Changed\n\nChange `shipit` behavior.\n\n## Release Notes\n\n`auto shipit` will only ship to `latest` on the base branch ([which is configurable]()). If ran locally or from a PR it will create a `canary` release that doesn't interfere with your `latest` release.\n\nThis will create a special section at the top of the changelog that collects all the additional release notes from merged PRs. Below is a sample of what it might look like.\n"
  },
  {
    "path": [
      "Publishing",
      "changelog",
      "Additional Release notes",
      "Release Notes"
    ],
    "url": "docs/generated/changelog#release-notes",
    "content": "\nFrom #371\nauto shipit will only ship to latest on the base branch (which is configurable). If ran locally or from a PR it will create a canary release that doesn't interfere with your latest release.\n"
  },
  {
    "path": [
      "Publishing",
      "changelog",
      "Additional Release notes",
      "Release Notes",
      "💥 Breaking Change"
    ],
    "url": "docs/generated/changelog#-breaking-change",
    "content": "\nshipit will publish a canary locally when not on baseBranch #371 (@hipstersmoothie)"
  },
  {
    "path": [
      "Publishing",
      "changelog",
      "Additional Release notes",
      "Release Notes",
      "Authors: 1"
    ],
    "url": "docs/generated/changelog#authors-1",
    "content": "\nAndrew Lisowski (@hipstersmoothie)"
  },
  {
    "path": [
      "Package Manager Plugins",
      "Chrome Web Store"
    ],
    "url": "docs/generated/chrome",
    "content": "\nThis plugin allows you to automate the publishing of chrome extensions\nExample Repo: here"
  },
  {
    "path": [
      "Package Manager Plugins",
      "Chrome Web Store",
      "Prerequisites"
    ],
    "url": "docs/generated/chrome#prerequisites",
    "content": "\nTo publish to the chrome web store you will need the following secrets set in your environment. See here for a guide one how to get these values.\nCLIENT_IDCLIENT_SECRETREFRESH_TOKEN"
  },
  {
    "path": [
      "Package Manager Plugins",
      "Chrome Web Store",
      "Installation"
    ],
    "url": "docs/generated/chrome#installation",
    "content": "\nThis plugin is not included with the auto CLI installed via NPM. To install:\nnpm i --save-dev @auto-it/chrome\n# or\nyarn add -D @auto-it/chrome\nnpm i --save-dev @auto-it/chrome\n# or\nyarn add -D @auto-it/chrome\n\nWARNING: You can only use one \"package manager\" at a time!\nMixing them will lead to undesired results."
  },
  {
    "path": [
      "Package Manager Plugins",
      "Chrome Web Store",
      "Usage"
    ],
    "url": "docs/generated/chrome#usage",
    "content": "\nYou must first pack/zip your plugin before running auto.\nThese environment variables tell auto what to publish.\nEXTENSION_ID - your chrome extensions unique ID (REQUIRED)EXTENSION_BUILD - Path to either a zip file, or a directory to be zip. defaults to extension.zip\nOr you can set these values in the autorc:\n{\n  \"plugins\": [\n    [\n      \"chrome\",\n      {\n        \"id\": \"1234\",\n        \"build\": \"path/to/zip/or/folder\",\n        \"manifest\": \"path/tp/manifest.json\"\n      }\n    ]\n  ]\n}\n{\n  \"plugins\": [\n    [\n      \"chrome\",\n      {\n        \"id\": \"1234\",\n        \"build\": \"path/to/zip/or/folder\",\n        \"manifest\": \"path/tp/manifest.json\"\n      }\n    ]\n  ]\n}\n\n⚠️ You must have a manifest.json for this plugin to work."
  },
  {
    "path": [
      "Package Manager Plugins",
      "CocoaPods Plugin"
    ],
    "url": "docs/generated/cocoapods",
    "content": "\nUse auto to version your CocoaPod, and push to your specs repository!"
  },
  {
    "path": [
      "Package Manager Plugins",
      "CocoaPods Plugin",
      "Installation"
    ],
    "url": "docs/generated/cocoapods#installation",
    "content": "\nThis plugin is not included with the auto CLI installed via NPM. To install:\nnpm i --save-dev @auto-it/cocoapods\n# or\nyarn add -D @auto-it/cocoapods\nnpm i --save-dev @auto-it/cocoapods\n# or\nyarn add -D @auto-it/cocoapods\n\nWARNING: You can only use one \"package manager\" at a time!\nMixing them will lead to undesired results."
  },
  {
    "path": [
      "Package Manager Plugins",
      "CocoaPods Plugin",
      "Usage"
    ],
    "url": "docs/generated/cocoapods#usage",
    "content": "\n{\n  \"plugins\": [\n    [\n      \"cocoapods\",\n      {\n        // Required, the relative path to your podspec file\n        \"podspecPath\": \"./Test.podspec\",\n        // Optional, the specs repo to push to\n        \"specsRepo\": \"https://github.com/intuit/TestSpecs.git\",\n        // Optional, flags to pass to the `pod repo push` command\n        \"flags\": [\"--sources=https://github.com/SpecRepo.git\"],\n        // Optional, specify a different executable for `pod`\n        \"podCommand\": \"bundle exec pod\"\n      }\n    ]\n    // other plugins\n  ]\n}\n{\n  \"plugins\": [\n    [\n      \"cocoapods\",\n      {\n        // Required, the relative path to your podspec file\n        \"podspecPath\": \"./Test.podspec\",\n        // Optional, the specs repo to push to\n        \"specsRepo\": \"https://github.com/intuit/TestSpecs.git\",\n        // Optional, flags to pass to the `pod repo push` command\n        \"flags\": [\"--sources=https://github.com/SpecRepo.git\"],\n        // Optional, specify a different executable for `pod`\n        \"podCommand\": \"bundle exec pod\"\n      }\n    ]\n    // other plugins\n  ]\n}\n"
  },
  {
    "path": [
      "Package Manager Plugins",
      "CocoaPods Plugin",
      "Requirements"
    ],
    "url": "docs/generated/cocoapods#requirements",
    "content": ""
  },
  {
    "path": [
      "Package Manager Plugins",
      "CocoaPods Plugin",
      "Requirements",
      "General"
    ],
    "url": "docs/generated/cocoapods#general",
    "content": "\nThe machine running this plugin must have the CocoaPods pod CLI installed already, or podCommand specified in your plugin configuration.Your podspec file must pass pod lib lint in order for publishing to a Specs repository to work.All warnings and errors must be addressed before attempting to push to a Specs repository.Using the logging flags with Auto (auto -v, auto -vv, auto -q) will also add the verbose or silent flags to the CocoaPod commands."
  },
  {
    "path": [
      "Package Manager Plugins",
      "CocoaPods Plugin",
      "Requirements",
      "Pushing to the CocoaPods Trunk"
    ],
    "url": "docs/generated/cocoapods#pushing-to-the-cocoapods-trunk",
    "content": "\nIf a specsRepo is not provided in the plugin options, this plugin will push to the CocoaPods trunk repository. This requires that the machine running this has followed the steps for pushing to trunk, the guide for that can be found here."
  },
  {
    "path": [
      "Package Manager Plugins",
      "CocoaPods Plugin",
      "Requirements",
      "Pushing to a private specs repo"
    ],
    "url": "docs/generated/cocoapods#pushing-to-a-private-specs-repo",
    "content": "\nIf specsRepo is provided in the configuration, this plugin will add that repo under a temporary name, push to it, and remove the repo from the CocoaPods installation on the machine. The machine that is running the plugin must have the appropriate git credentials to push to that repository."
  },
  {
    "path": [
      "Package Manager Plugins",
      "CocoaPods Plugin",
      "Requirements",
      "Pushing to a private specs repo",
      "Note"
    ],
    "url": "docs/generated/cocoapods#note",
    "content": "\nWhen pushing to a private Specs repo, this plugin will temporarily create a repository with the name autoPublishRepo using pod repo add, and will remove it when the release has completed."
  },
  {
    "path": [
      "PR Interaction",
      "comment"
    ],
    "url": "docs/generated/comment",
    "content": "\nComment on a pull request with a markdown message. Each comment has a context, and each context only has one comment."
  },
  {
    "path": [
      "PR Interaction",
      "comment",
      "Options"
    ],
    "url": "docs/generated/comment#options",
    "content": "\nFlagTypeDescription--prNumberThe pull request the command should use. Detects PR number in CI--contextStringA string label to differentiate this status from others--edit, -eBooleanEdit old comment--deleteBooleanDelete old comment--message, -mStringMessage to post to comment--dry-run, -dBooleanReport what command will do but do not actually do anything"
  },
  {
    "path": [
      "PR Interaction",
      "comment",
      "Examples"
    ],
    "url": "docs/generated/comment#examples",
    "content": "\nauto comment --delete\nauto comment --delete\n\nauto comment --pr 123 --message \"# Why you're wrong...\"\nauto comment --pr 123 --message \"# Why you're wrong...\"\n\nauto comment --pr 123 --edit --message \"This smells...\" --context code-smell\nauto comment --pr 123 --edit --message \"This smells...\" --context code-smell\n"
  },
  {
    "path": [
      "PR Interaction",
      "comment",
      "Configurable Options"
    ],
    "url": "docs/generated/comment#configurable-options",
    "content": "\nYou can configure some of the options for the comment command in the .autorc.\neditdelete\nExample .autorc:\n{\n  \"comment\": {\n    \"edit\": true,\n    \"delete\": true\n  }\n}\n{\n  \"comment\": {\n    \"edit\": true,\n    \"delete\": true\n  }\n}\n"
  },
  {
    "path": [
      "Functionality Plugins",
      "Conventional Commits Plugin"
    ],
    "url": "docs/generated/conventional-commits",
    "content": "\nParse conventional commit messages and use them to calculate the version. This plugin will omit the PR HEAD if it isn't labeled and has a commit with a conventional-commit commit message.\nThe default behavior extends the conventional commits spec:\nType fix: => patchType feat: => minorType BREAKING: => majorA ! in the type indicated a breaking changeBREAKING CHANGE in the footer indicates a breaking changeAll other types are considered skip-release"
  },
  {
    "path": [
      "Functionality Plugins",
      "Conventional Commits Plugin",
      "Installation"
    ],
    "url": "docs/generated/conventional-commits#installation",
    "content": "\nThis plugin is not included with the auto CLI installed via NPM. To install:\nnpm i --save-dev @auto-it/conventional-commits\n# or\nyarn add -D @auto-it/conventional-commits\nnpm i --save-dev @auto-it/conventional-commits\n# or\nyarn add -D @auto-it/conventional-commits\n"
  },
  {
    "path": [
      "Functionality Plugins",
      "Conventional Commits Plugin",
      "Usage"
    ],
    "url": "docs/generated/conventional-commits#usage",
    "content": "\n{\n  \"plugins\": [\n    \"npm\",\n    \"conventional-commits\"\n    // other plugins\n  ]\n}\n{\n  \"plugins\": [\n    \"npm\",\n    \"conventional-commits\"\n    // other plugins\n  ]\n}\n"
  },
  {
    "path": [
      "Functionality Plugins",
      "Conventional Commits Plugin",
      "Options"
    ],
    "url": "docs/generated/conventional-commits#options",
    "content": ""
  },
  {
    "path": [
      "Functionality Plugins",
      "Conventional Commits Plugin",
      "Options",
      "preset"
    ],
    "url": "docs/generated/conventional-commits#preset",
    "content": "\nYou can use any conventional-changelog preset with this plugin.\nUsing a preset will completely override this plugin's default behavior with whatever the preset defines.\n{\n  \"plugins\": [\n    \"npm\",\n    [\"conventional-commits\", { \"preset\": \"angular\" }]\n    // other plugins\n  ]\n}\n{\n  \"plugins\": [\n    \"npm\",\n    [\"conventional-commits\", { \"preset\": \"angular\" }]\n    // other plugins\n  ]\n}\n"
  },
  {
    "path": [
      "Functionality Plugins",
      "Conventional Commits Plugin",
      "Options",
      "defaultReleaseType"
    ],
    "url": "docs/generated/conventional-commits#defaultreleasetype",
    "content": "\nThe default release type to apply when the conventional commit isn't \"fix\", \"feat\" or \"breaking\" (ex: \"chore:\").\nDefaults to skip.\n{\n  \"plugins\": [\n    \"npm\",\n    [\"conventional-commits\", { \"defaultReleaseType\": \"patch\" }]\n    // other plugins\n  ]\n}\n{\n  \"plugins\": [\n    \"npm\",\n    [\"conventional-commits\", { \"defaultReleaseType\": \"patch\" }]\n    // other plugins\n  ]\n}\n"
  },
  {
    "path": [
      "Package Manager Plugins",
      "Crates Plugin"
    ],
    "url": "docs/generated/crates",
    "content": "\nDeploy Rust crates to crates.io."
  },
  {
    "path": [
      "Package Manager Plugins",
      "Crates Plugin",
      "Installation"
    ],
    "url": "docs/generated/crates#installation",
    "content": "\nThis plugin is not included with the auto CLI installed via NPM. To install:\nnpm i --save-dev @auto-it/crates\n# or\nyarn add -D @auto-it/crates\nnpm i --save-dev @auto-it/crates\n# or\nyarn add -D @auto-it/crates\n\nWARNING: You can only use one \"package manager\" at a time!\nMixing them will lead to undesired results."
  },
  {
    "path": [
      "Package Manager Plugins",
      "Crates Plugin",
      "Usage"
    ],
    "url": "docs/generated/crates#usage",
    "content": "\n{\n  \"plugins\": [\"crates\"]\n}\n{\n  \"plugins\": [\"crates\"]\n}\n"
  },
  {
    "path": [
      "Package Manager Plugins",
      "Crates Plugin",
      "Crates Project Configuration"
    ],
    "url": "docs/generated/crates#crates-project-configuration",
    "content": "\nThis plugin handles incrementing the crate version, but it requires that your crate be ready for publishing. You can view the publishing reference for more information on that process.\nWhen ran on a machine with ~/cargo/credentials, that file will automatically be used by Cargo. For machines that do not have this file (like CI builds), the CARGO_REGISTRY_TOKEN environment variable is expected for Cargo's publish command as per the publish options."
  },
  {
    "path": [
      "Setup",
      "create-labels"
    ],
    "url": "docs/generated/create-labels",
    "content": "\nCreate your project's labels on github. If labels exist it will update them."
  },
  {
    "path": [
      "Setup",
      "create-labels",
      "Options"
    ],
    "url": "docs/generated/create-labels#options",
    "content": "\nFlagTypeDescription--dry-run, -dBooleanReport what command will do but do not actually do anything"
  },
  {
    "path": [
      "Setup",
      "create-labels",
      "Examples"
    ],
    "url": "docs/generated/create-labels#examples",
    "content": "\nauto create-labels\nauto create-labels\n\n⚠️ For this to work you must have a `GH_TOKEN` set, ex: `GH_TOKEN=YOUR_TOKEN auto create-labels`"
  },
  {
    "path": [
      "Package Manager Plugins",
      "Docker Plugin"
    ],
    "url": "docs/generated/docker",
    "content": "\nThis plugin automates tagging and publishing images to a docker registry."
  },
  {
    "path": [
      "Package Manager Plugins",
      "Docker Plugin",
      "Prerequisites"
    ],
    "url": "docs/generated/docker#prerequisites",
    "content": "\nTo publish to a docker registry, you'll first need to authenticate with the target registry. For example, the Docker Login Action for GitHub, or the withRegistry helper in Jenkins."
  },
  {
    "path": [
      "Package Manager Plugins",
      "Docker Plugin",
      "Installation"
    ],
    "url": "docs/generated/docker#installation",
    "content": "\nThis plugin is not included with the auto CLI installed via NPM. To install:\nnpm i --save-dev @auto-it/docker\n# or\nyarn add -D @auto-it/docker\nnpm i --save-dev @auto-it/docker\n# or\nyarn add -D @auto-it/docker\n"
  },
  {
    "path": [
      "Package Manager Plugins",
      "Docker Plugin",
      "Usage"
    ],
    "url": "docs/generated/docker#usage",
    "content": "\nYou must first must build the desired image to publish.\nThese environment variables tell auto what to publish.\nIMAGE - The image ID, digest, or tag of the locally available image to tag and publish. This is required unless you want to statically tag the local image, in which case you can provide it as an option.\n{\n  \"plugins\": [\n    [\"docker\", { \"registry\": \"ghcr.io/my/app\" }]\n    // other plugins\n  ]\n}\n{\n  \"plugins\": [\n    [\"docker\", { \"registry\": \"ghcr.io/my/app\" }]\n    // other plugins\n  ]\n}\n\nIf you'd like to tag releases with latest too, you can specify the tagLatest option:\n{\n  \"plugins\": [[\"docker\", { \"registry\": \"ghcr.io/my/app\", \"tagLatest\": true }]]\n}\n{\n  \"plugins\": [[\"docker\", { \"registry\": \"ghcr.io/my/app\", \"tagLatest\": true }]]\n}\n\nIf you're tagging the locally built image in a static manner, you can also pass image instead of IMAGE as an environment variable.\n{\n  \"plugins\": [[\"docker\", { \"registry\": \"ghcr.io/my/app\", \"image\": \"myapp\" }]]\n}\n{\n  \"plugins\": [[\"docker\", { \"registry\": \"ghcr.io/my/app\", \"image\": \"myapp\" }]]\n}\n"
  },
  {
    "path": [
      "Functionality Plugins",
      "Exec Plugin"
    ],
    "url": "docs/generated/exec",
    "content": "\nTap into hooks and run scripts on the terminal.\nRead more about the available hooks."
  },
  {
    "path": [
      "Functionality Plugins",
      "Exec Plugin",
      "Installation"
    ],
    "url": "docs/generated/exec#installation",
    "content": "\nThis plugin is not included with the auto CLI installed via NPM. To install:\nnpm i --save-dev @auto-it/exec\n# or\nyarn add -D @auto-it/exec\nnpm i --save-dev @auto-it/exec\n# or\nyarn add -D @auto-it/exec\n"
  },
  {
    "path": [
      "Functionality Plugins",
      "Exec Plugin",
      "Usage"
    ],
    "url": "docs/generated/exec#usage",
    "content": "\nHere is an example of replacing the npm plugins with a light-weight version.\nAll args to a hook are exposed on the process in environment variables.\nThe format looks like $ARG_0, $ARG_1, and so on.\nPlease look at the docs for writing plugins for more detail on what's available.\n{\n  \"plugins\": [\n    [\n      \"exec\",\n      {\n        \"version\": \"npm version $ARG_0\",\n        \"publish\": \"npm publish && git push --tags\",\n        \"afterRelease\": \"yarn docs && push-dir --dir=docs --branch=gh-pages\"\n      }\n    ]\n    // other plugins\n  ]\n}\n{\n  \"plugins\": [\n    [\n      \"exec\",\n      {\n        \"version\": \"npm version $ARG_0\",\n        \"publish\": \"npm publish && git push --tags\",\n        \"afterRelease\": \"yarn docs && push-dir --dir=docs --branch=gh-pages\"\n      }\n    ]\n    // other plugins\n  ]\n}\n\n⚠️ If you are tapping into a waterfall or bail hook you will need to return some value (ex: JSON or a boolean). Please refer to the documentation and return the right thing!"
  },
  {
    "path": [
      "Functionality Plugins",
      "First Time Contributor Plugin"
    ],
    "url": "docs/generated/first-time-contributor",
    "content": "\nThank first time contributors for their work right in your release notes."
  },
  {
    "path": [
      "Functionality Plugins",
      "First Time Contributor Plugin",
      "Installation"
    ],
    "url": "docs/generated/first-time-contributor#installation",
    "content": "\nThis plugin is not included with the auto CLI installed via NPM. To install:\nnpm i --save-dev @auto-it/first-time-contributor\n# or\nyarn add -D @auto-it/first-time-contributor\nnpm i --save-dev @auto-it/first-time-contributor\n# or\nyarn add -D @auto-it/first-time-contributor\n"
  },
  {
    "path": [
      "Functionality Plugins",
      "First Time Contributor Plugin",
      "Usage"
    ],
    "url": "docs/generated/first-time-contributor#usage",
    "content": "\nSimply add the plugins to your auto configuration.\n{\n  \"plugins\": [\"first-time-contributor\"]\n}\n{\n  \"plugins\": [\"first-time-contributor\"]\n}\n"
  },
  {
    "path": [
      "Package Manager Plugins",
      "Gem Plugin"
    ],
    "url": "docs/generated/gem",
    "content": "\nA plugin that automates publishing ruby gems."
  },
  {
    "path": [
      "Package Manager Plugins",
      "Gem Plugin",
      "Prerequisites"
    ],
    "url": "docs/generated/gem#prerequisites",
    "content": "\nTo publish to your gem you will need you your environment authenticated.\nYou can either create a ~/.gem/credentials yourself or provide RUBYGEMS_API_KEY as an environment variable.\nThis plugin also looks in your .gemspec and lib/**/version.rb for a version.\nauto will use this value and keep it up to date."
  },
  {
    "path": [
      "Package Manager Plugins",
      "Gem Plugin",
      "Installation"
    ],
    "url": "docs/generated/gem#installation",
    "content": "\nThis plugin is not included with the auto CLI installed via NPM. To install:\nnpm i --save-dev @auto-it/gem\n# or\nyarn add -D @auto-it/gem\nnpm i --save-dev @auto-it/gem\n# or\nyarn add -D @auto-it/gem\n\nWARNING: You can only use one \"package manager\" at a time!\nMixing them will lead to undesired results."
  },
  {
    "path": [
      "Package Manager Plugins",
      "Gem Plugin",
      "Usage"
    ],
    "url": "docs/generated/gem#usage",
    "content": "\n{\n  \"plugins\": [\"gem\"]\n}\n{\n  \"plugins\": [\"gem\"]\n}\n"
  },
  {
    "path": [
      "Package Manager Plugins",
      "Gem Plugin",
      "Options"
    ],
    "url": "docs/generated/gem#options",
    "content": ""
  },
  {
    "path": [
      "Package Manager Plugins",
      "Gem Plugin",
      "Options",
      "Release Command"
    ],
    "url": "docs/generated/gem#release-command",
    "content": "\nWhen auto publishes your gem it does it by running a command.\nThe default for this is bundle exec rake release.\nThe following is an example of using gem-release to publish the gem.\nMake sure to tag and push in this command!\n.autorc:\n{\n  \"plugins\": [\n    [\n      \"gem\",\n      {\n        \"releaseCommand\": \"gem release --tag --push\"\n      }\n    ]\n  ]\n}\n{\n  \"plugins\": [\n    [\n      \"gem\",\n      {\n        \"releaseCommand\": \"gem release --tag --push\"\n      }\n    ]\n  ]\n}\n"
  },
  {
    "path": [
      "Functionality Plugins",
      "GitHub Pages Plugin"
    ],
    "url": "docs/generated/gh-pages",
    "content": "\nAutomate publishing to your gh-pages documentation website\nauto will push a directory to your project's gh-pages branch:\non every releaseif the documentation label is on the pull request\nWhat is a gh-pages branch?\nThe gh-pages branch is a special branch in your repository that you can use to store your built website.\nThis branch will not track any of the source files for your project, but will have things like an index.html and all the other files needed to render your website.\nThe benefit of this is that you don't have to store any dist files in your baseBranch.\nTake a look at auto's gh-pages branch/"
  },
  {
    "path": [
      "Functionality Plugins",
      "GitHub Pages Plugin",
      "Installation"
    ],
    "url": "docs/generated/gh-pages#installation",
    "content": "\nThis plugin is not included with the auto CLI installed via NPM. To install:\nnpm i --save-dev @auto-it/gh-pages\n# or\nyarn add -D @auto-it/gh-pages\nnpm i --save-dev @auto-it/gh-pages\n# or\nyarn add -D @auto-it/gh-pages\n"
  },
  {
    "path": [
      "Functionality Plugins",
      "GitHub Pages Plugin",
      "Usage"
    ],
    "url": "docs/generated/gh-pages#usage",
    "content": "\nAll you need to do a provide that path to your build documentation website.\n{\n  \"plugins\": [\n    [\"gh-pages\", { \"dir\": \"./path/to/built/docs/website\" }]\n    // other plugins\n  ]\n}\n{\n  \"plugins\": [\n    [\"gh-pages\", { \"dir\": \"./path/to/built/docs/website\" }]\n    // other plugins\n  ]\n}\n"
  },
  {
    "path": [
      "Functionality Plugins",
      "GitHub Pages Plugin",
      "Usage",
      "Build Your Docs"
    ],
    "url": "docs/generated/gh-pages#build-your-docs",
    "content": "\nIf you also want auto to run the build for you docs site provide the buildCommand option.\n{\n  \"plugins\": [\n    [\n      \"gh-pages\",\n      {\n        \"buildCommand\": \"npm run build:docs\",\n        \"dir\": \"./path/to/built/docs/website\"\n      }\n    ]\n    // other plugins\n  ]\n}\n{\n  \"plugins\": [\n    [\n      \"gh-pages\",\n      {\n        \"buildCommand\": \"npm run build:docs\",\n        \"dir\": \"./path/to/built/docs/website\"\n      }\n    ]\n    // other plugins\n  ]\n}\n\nYou must also make sure that your built website is in your .gitignore.\nOtherwise your release will fail because of uncommitted changes.\n.gitignore:\n./path/to/built/docs/website\n./path/to/built/docs/website\n"
  },
  {
    "path": [
      "Functionality Plugins",
      "GitHub Pages Plugin",
      "Usage",
      "Pages Branch"
    ],
    "url": "docs/generated/gh-pages#pages-branch",
    "content": "\nYou can configure the branch auto pushes to with the branch option.\n{\n  \"plugins\": [\n    [\n      \"gh-pages\",\n      {\n        \"branch\": \"docs\",\n        \"dir\": \"./path/to/built/docs/website\"\n      }\n    ]\n    // other plugins\n  ]\n}\n{\n  \"plugins\": [\n    [\n      \"gh-pages\",\n      {\n        \"branch\": \"docs\",\n        \"dir\": \"./path/to/built/docs/website\"\n      }\n    ]\n    // other plugins\n  ]\n}\n"
  },
  {
    "path": [
      "Functionality Plugins",
      "GitHub Pages Plugin",
      "Usage",
      "Documentation Label"
    ],
    "url": "docs/generated/gh-pages#documentation-label",
    "content": "\nYou can configure the label auto looks for with the label option.\n{\n  \"plugins\": [\n    [\n      \"gh-pages\",\n      {\n        \"label\": \"website\",\n        \"dir\": \"./path/to/built/docs/website\"\n      }\n    ]\n    // other plugins\n  ]\n}\n{\n  \"plugins\": [\n    [\n      \"gh-pages\",\n      {\n        \"label\": \"website\",\n        \"dir\": \"./path/to/built/docs/website\"\n      }\n    ]\n    // other plugins\n  ]\n}\n"
  },
  {
    "path": [
      "Package Manager Plugins",
      "Git Tag Plugin"
    ],
    "url": "docs/generated/git-tag",
    "content": "\nManage your projects version through just a git tag.\nThis plugin is loaded by default when auto is installed through the binaries released on GitHub.\nIf you're using this plugin you aren't releasing your code to any platform (npm, maven, etc). Instead you version calculations is done entirely though git tags.\nThis plugin only:\ngets last git tagbump it to new versioncreate new tagspush to github\nIt will not:\nPublish to a specific platformUse any platform specific project information (ex: author or repo from a package.json)"
  },
  {
    "path": [
      "Package Manager Plugins",
      "Git Tag Plugin",
      "Installation"
    ],
    "url": "docs/generated/git-tag#installation",
    "content": "\nThis plugin is not included with the auto CLI installed via NPM. To install:\nnpm i --save-dev @auto-it/git-tag\n# or\nyarn add -D @auto-it/git-tag\nnpm i --save-dev @auto-it/git-tag\n# or\nyarn add -D @auto-it/git-tag\n\nWARNING: You can only use one \"package manager\" at a time!\nMixing them will lead to undesired results."
  },
  {
    "path": [
      "Package Manager Plugins",
      "Git Tag Plugin",
      "Usage"
    ],
    "url": "docs/generated/git-tag#usage",
    "content": "\nSimply add the plugins to your auto configuration.\n{\n  \"plugins\": [\"git-tag\"]\n}\n{\n  \"plugins\": [\"git-tag\"]\n}\n"
  },
  {
    "path": [
      "Package Manager Plugins",
      "Git Tag Plugin",
      "Canary Releases"
    ],
    "url": "docs/generated/git-tag#canary-releases",
    "content": "\nThis plugin does not support canaries.\nFor canary support try using the upload-assets plugin"
  },
  {
    "path": [
      "Package Manager Plugins",
      "Gradle Plugin"
    ],
    "url": "docs/generated/gradle",
    "content": "\nRelease a Java project using gradle.\nsupports both -snapshot and -snapshot-less versioning"
  },
  {
    "path": [
      "Package Manager Plugins",
      "Gradle Plugin",
      "Installation"
    ],
    "url": "docs/generated/gradle#installation",
    "content": "\nThis plugin is not included with the auto CLI installed via NPM. To install:\nnpm i --save-dev @auto-it/gradle\n# or\nyarn add -D @auto-it/gradle\nnpm i --save-dev @auto-it/gradle\n# or\nyarn add -D @auto-it/gradle\n\nWARNING: You can only use one \"package manager\" at a time!\nMixing them will lead to undesired results."
  },
  {
    "path": [
      "Package Manager Plugins",
      "Gradle Plugin",
      "Usage"
    ],
    "url": "docs/generated/gradle#usage",
    "content": "\n{\n  \"plugins\": [\n    [\n      \"gradle\",\n      {\n        // An optional gradle binary cmd/path relative to your project\n        // @default /usr/bin/gradle\n        \"gradleCommand\": \"./gradlew\",\n\n        // An optional gradle argument list -- IE any gradle option allowed for the version\n        // of gradle you're using\n        // @default []\n        \"gradleOptions\": [\"-P someProp=someVal\"]\n      }\n    ]\n    // other plugins\n  ]\n}\n{\n  \"plugins\": [\n    [\n      \"gradle\",\n      {\n        // An optional gradle binary cmd/path relative to your project\n        // @default /usr/bin/gradle\n        \"gradleCommand\": \"./gradlew\",\n\n        // An optional gradle argument list -- IE any gradle option allowed for the version\n        // of gradle you're using\n        // @default []\n        \"gradleOptions\": [\"-P someProp=someVal\"]\n      }\n    ]\n    // other plugins\n  ]\n}\n"
  },
  {
    "path": [
      "Package Manager Plugins",
      "Gradle Plugin",
      "Gradle Project Configuration"
    ],
    "url": "docs/generated/gradle#gradle-project-configuration",
    "content": "\nThis plugin uses the (gradle release plugin)[https://github.com/researchgate/gradle-release] to update the version. Make sure the the latest gradle-release-plugin is in your build.gradle.\nplugins {\n  id 'net.researchgate.release' version '2.6.0' // gradle release plugin\n}\nplugins {\n  id 'net.researchgate.release' version '2.6.0' // gradle release plugin\n}\n"
  },
  {
    "path": [
      "Package Manager Plugins",
      "Gradle Plugin",
      "Gradle Project Configuration",
      "Publish"
    ],
    "url": "docs/generated/gradle#publish",
    "content": "\nThis plugin will also call the publish task with the release version, if configured in your project."
  },
  {
    "path": [
      "Package Manager Plugins",
      "Gradle Plugin",
      "Gradle Project Configuration",
      "Configure snapshotSuffix"
    ],
    "url": "docs/generated/gradle#configure-snapshotsuffix",
    "content": "\nThis plugin will use the snapshotSuffix in gradle.properties or build.gradle if configured."
  },
  {
    "path": [
      "Package Manager Plugins",
      "Gradle Plugin",
      "Gradle Project Configuration",
      "Build After Version Bump Automatically"
    ],
    "url": "docs/generated/gradle#build-after-version-bump-automatically",
    "content": "\nThis plugin will run a release build to create release artifacts."
  },
  {
    "path": [
      "Setup",
      "info"
    ],
    "url": "docs/generated/info",
    "content": "\nDetermine the environment, check if auto is set up correctly, and list plugins."
  },
  {
    "path": [
      "Setup",
      "info",
      "Options"
    ],
    "url": "docs/generated/info#options",
    "content": "\nFlagTypeDescription--list-pluginsBooleanList the available plugins"
  },
  {
    "path": [
      "Setup",
      "info",
      "Examples"
    ],
    "url": "docs/generated/info#examples",
    "content": "\nauto info\nauto info\n"
  },
  {
    "path": [
      "Setup",
      "init"
    ],
    "url": "docs/generated/init",
    "content": "\nInteractive setup for minimum working configuration."
  },
  {
    "path": [
      "Setup",
      "init",
      "Examples"
    ],
    "url": "docs/generated/init#examples",
    "content": "\nauto init\nauto init\n"
  },
  {
    "path": [
      "Functionality Plugins",
      "Jira Plugin"
    ],
    "url": "docs/generated/jira",
    "content": "\nInclude links to Jira stories in your changelogs.\nThis plugin will create links to Jira stories using the following syntax in a pull request title:\nJIRA-123: My pull request title\n[JIRA-123]: My pull request title\nJIRA-123: My pull request title\n[JIRA-123]: My pull request title\n"
  },
  {
    "path": [
      "Functionality Plugins",
      "Jira Plugin",
      "Installation"
    ],
    "url": "docs/generated/jira#installation",
    "content": "\nThis plugin is not included with the auto CLI installed via NPM. To install:\nnpm i --save-dev @auto-it/jira\n# or\nyarn add -D @auto-it/jira\nnpm i --save-dev @auto-it/jira\n# or\nyarn add -D @auto-it/jira\n"
  },
  {
    "path": [
      "Functionality Plugins",
      "Jira Plugin",
      "Usage"
    ],
    "url": "docs/generated/jira#usage",
    "content": "\nTo use the plugin include it in your .autorc\n{\n  \"plugins\": [\n    [\"jira\", { \"url\": \"https://url-to-your-jira.com\" }],\n    // or\n    [\"jira\", \"https://url-to-your-jira.com\"]\n  ]\n}\n{\n  \"plugins\": [\n    [\"jira\", { \"url\": \"https://url-to-your-jira.com\" }],\n    // or\n    [\"jira\", \"https://url-to-your-jira.com\"]\n  ]\n}\n"
  },
  {
    "path": [
      "PR Interaction",
      "label"
    ],
    "url": "docs/generated/label",
    "content": "\nGet the labels for a pull request. Doesn't do much, but the return value lets you write you own scripts based off of the PR labels!"
  },
  {
    "path": [
      "PR Interaction",
      "label",
      "Options"
    ],
    "url": "docs/generated/label#options",
    "content": "\nFlagTypeDescription--prNumberThe pull request the command should use. Detects PR number in CI (defaults to last merged PR)--existsStringChecks for existence of a specific label"
  },
  {
    "path": [
      "PR Interaction",
      "label",
      "Examples"
    ],
    "url": "docs/generated/label#examples",
    "content": "\nauto label --pr 123\nauto label --pr 123\n"
  },
  {
    "path": [
      "PR Interaction",
      "label",
      "Using in scripts"
    ],
    "url": "docs/generated/label#using-in-scripts",
    "content": "\nThe following will only run the test:visual script when the PR has has the\nVisual label.\nexport PATH=$(npm bin):$PATH\n\nif auto label --pr $PR_NUMBER --exists Visual;\nthen\n  npm run test:visual\nfi\nexport PATH=$(npm bin):$PATH\n\nif auto label --pr $PR_NUMBER --exists Visual;\nthen\n  npm run test:visual\nfi\n"
  },
  {
    "path": [
      "PR Interaction",
      "label",
      "Without PR Number"
    ],
    "url": "docs/generated/label#without-pr-number",
    "content": "\nRunning auto label without the PR number will:\nWhen run in baseBranch will get the labels for the last merged PRWhen run for a PR in CI will use the PR's number"
  },
  {
    "path": [
      "Publishing",
      "latest"
    ],
    "url": "docs/generated/latest",
    "content": "\nRun the full auto release pipeline. Force a release to latest and bypass shipit safeguards."
  },
  {
    "path": [
      "Publishing",
      "latest",
      "Options"
    ],
    "url": "docs/generated/latest#options",
    "content": "\nFlagTypeDescription--nameStringGit name to commit  with. Defaults to package definition for the platform--emailStringGit email to commit with. Defaults to package definition for the platform--only-publish-with-release-labelBooleanOnly bump version if 'release' label is on pull request--base-branchStringBranch to treat as the base branch--dry-run, -dBooleanReport what command will do but do not actually do anything--no-version-prefixBooleanUse the version as the tag without the 'v' prefix. WARNING: some plugins might need extra config to use this option (ex: npm)--prereleaseBooleanPublish a prerelease on GitHub.--titleStringOverride the title used in the addition to the CHANGELOG.md.--message, -mStringMessage to commit the changelog with. Defaults to 'Update CHANGELOG.md [skip ci]'--quiet, -qBooleanPrint only the result of the command--no-changelogBooleanSkip creating the changelog"
  },
  {
    "path": [
      "Publishing",
      "latest",
      "Examples"
    ],
    "url": "docs/generated/latest#examples",
    "content": "\nauto latest\nauto latest\n"
  },
  {
    "path": [
      "Publishing",
      "latest",
      "Configurable Options"
    ],
    "url": "docs/generated/latest#configurable-options",
    "content": "\nYou can configure some of the options for the latest command in the .autorc.\nprereleasemessageno-changelog\nExample .autorc:\n{\n  \"latest\": {\n    \"prerelease\": true,\n    \"message\": \"string\",\n    \"noChangelog\": true\n  }\n}\n{\n  \"latest\": {\n    \"prerelease\": true,\n    \"message\": \"string\",\n    \"noChangelog\": true\n  }\n}\n"
  },
  {
    "path": [
      "Functionality Plugins",
      "Magic-Zero Plugin"
    ],
    "url": "docs/generated/magic-zero",
    "content": "\nA plugin that closely adheres to semver versioning for 0.0.x and 0.x.y releases.\nIn the default auto experience the patch, minor, and major only increment the corresponding digit in the version.\nThe rules for incrementing version < 1.0.0 are not as intuitive or agreed upon.\nThis plugin adds a new label (graduate) and changes auto's behavior to do the following:\n0.0.x:\nStarting version: 0.0.1\npatch => 0.0.2\nminor => 0.0.2\nmajor => 0.0.2\ngraduate => 0.1.0\n0.x.y:\nStarting version: 0.1.0\npatch => 0.1.1\nminor => 0.1.1\nmajor => 0.2.0\ngraduate => 1.0.0\nOnce you're project is >= 1.0.0 this plugin effectively does nothing."
  },
  {
    "path": [
      "Functionality Plugins",
      "Magic-Zero Plugin",
      "Installation"
    ],
    "url": "docs/generated/magic-zero#installation",
    "content": "\nThis plugin is not included with the auto CLI installed via NPM. To install:\nnpm i --save-dev @auto-it/magic-zero\n# or\nyarn add -D @auto-it/magic-zero\nnpm i --save-dev @auto-it/magic-zero\n# or\nyarn add -D @auto-it/magic-zero\n"
  },
  {
    "path": [
      "Functionality Plugins",
      "Magic-Zero Plugin",
      "Usage"
    ],
    "url": "docs/generated/magic-zero#usage",
    "content": "\n{\n  \"plugins\": [\n    \"magic-zero\"\n    // other plugins\n  ]\n}\n{\n  \"plugins\": [\n    \"magic-zero\"\n    // other plugins\n  ]\n}\n"
  },
  {
    "path": [
      "Functionality Plugins",
      "Magic-Zero Plugin",
      "Options"
    ],
    "url": "docs/generated/magic-zero#options",
    "content": ""
  },
  {
    "path": [
      "Functionality Plugins",
      "Magic-Zero Plugin",
      "Options",
      "label"
    ],
    "url": "docs/generated/magic-zero#label",
    "content": "\nThe label to graduate a version to the next left 0 digit.\n{\n  \"plugins\": [\n    [\"magic-zero\", { \"label\": \"super major\" }]\n    // other plugins\n  ]\n}\n{\n  \"plugins\": [\n    [\"magic-zero\", { \"label\": \"super major\" }]\n    // other plugins\n  ]\n}\n\nIf you want to customize the label color/description you must define the label in your .autorc.\n{\n  \"plugins\": [\n    [\"magic-zero\", { \"label\": \"super major\" }]\n    // other plugins\n  ],\n  \"labels\": [\n    {\n      \"name\": \"super major\",\n      \"description\": \"Graduate a version to the next left 0 digit\",\n      \"releaseType\": \"major\",\n      \"color\": \"#000\"\n    }\n  ]\n}\n{\n  \"plugins\": [\n    [\"magic-zero\", { \"label\": \"super major\" }]\n    // other plugins\n  ],\n  \"labels\": [\n    {\n      \"name\": \"super major\",\n      \"description\": \"Graduate a version to the next left 0 digit\",\n      \"releaseType\": \"major\",\n      \"color\": \"#000\"\n    }\n  ]\n}\n"
  },
  {
    "path": [
      "Package Manager Plugins",
      "Maven Plugin"
    ],
    "url": "docs/generated/maven",
    "content": "\nRelease a Java project to a maven repository."
  },
  {
    "path": [
      "Package Manager Plugins",
      "Maven Plugin",
      "Installation"
    ],
    "url": "docs/generated/maven#installation",
    "content": "\nThis plugin is not included with the auto CLI installed via NPM. To install:\nnpm i --save-dev @auto-it/maven\n# or\nyarn add -D @auto-it/maven\nnpm i --save-dev @auto-it/maven\n# or\nyarn add -D @auto-it/maven\n\nWARNING: You can only use one \"package manager\" at a time!\nMixing them will lead to undesired results."
  },
  {
    "path": [
      "Package Manager Plugins",
      "Maven Plugin",
      "Usage"
    ],
    "url": "docs/generated/maven#usage",
    "content": "\nThis plugin makes recursive changes to all pom.xml files in the project, with the following assumptions:\na. The project is a multi-module project.\nb. The parent pom.xml file is located in the root directory of the repo.\nc. The parent pom.xml contains the version.\nd. Sub-modules have the same version as the parent pom.xml.\nauto will detect if the parent pom.xml file has the versions-maven-plugin configured, and\nif so, use it to set the version on the parent and all child pom.xml files. If not, then auto will modify the parent\nand all child pom.xml files using a DOM parser and XML serializer. This has the effect of losing formatting. Therefore\nit then runs the serialized XML through the prettier \"html\" pretty-printer.\nThis means that if the versions-maven-plugin isn't available, the pom.xml files will be pretty-printed using prettier\nformatter with the following default settings:\nprintWidth: 120 (configurable - see below)tabWidth: 4 (configurable - see below)parser: \"html\"\n{\n  \"plugins\": [\n    [\n      \"maven\",\n      {\n        // An optional maven binary cmd/path\n        // @default /usr/bin/mvn\n        \"mavenCommand\": \"mvn\",\n\n        // An optional maven argument list - e.g. any maven option allowed for the version\n        // of maven you're using\n        // @default []\n        \"mavenOptions\": [\"-DskipTests\", \"-P some-profile\"],\n\n        // An optional set of goals to execute for release\n        // @default [\"deploy\", \"site-deploy\"]\n        \"mavenReleaseGoals\": [\"deploy\"],\n\n        // An optional path to a maven settings.xml file\n        // @default \"\"\n        \"mavenSettings\": \"./.github/maven/settings.xml\",\n\n        // An optional printWidth for the prettier pretty-printer\n        // @default 120\n        \"printWidth\": 80,\n\n        // An optional tabWidth for the prettier pretty-printer\n        // @default 4\n        \"tabWidth\": 4\n      }\n    ]\n    // other plugins\n  ]\n}\n{\n  \"plugins\": [\n    [\n      \"maven\",\n      {\n        // An optional maven binary cmd/path\n        // @default /usr/bin/mvn\n        \"mavenCommand\": \"mvn\",\n\n        // An optional maven argument list - e.g. any maven option allowed for the version\n        // of maven you're using\n        // @default []\n        \"mavenOptions\": [\"-DskipTests\", \"-P some-profile\"],\n\n        // An optional set of goals to execute for release\n        // @default [\"deploy\", \"site-deploy\"]\n        \"mavenReleaseGoals\": [\"deploy\"],\n\n        // An optional path to a maven settings.xml file\n        // @default \"\"\n        \"mavenSettings\": \"./.github/maven/settings.xml\",\n\n        // An optional printWidth for the prettier pretty-printer\n        // @default 120\n        \"printWidth\": 80,\n\n        // An optional tabWidth for the prettier pretty-printer\n        // @default 4\n        \"tabWidth\": 4\n      }\n    ]\n    // other plugins\n  ]\n}\n"
  },
  {
    "path": [
      "Package Manager Plugins",
      "Maven Plugin",
      "Environment Variables"
    ],
    "url": "docs/generated/maven#environment-variables",
    "content": "\nNameDescriptionDefault valueMAVEN_COMMANDThe Maven command to use./usr/bin/mvnMAVEN_OPTIONSA list of maven command customizations to pass to maven.nullMAVEN_RELEASE_GOALSA list of maven goals to pass to maven for release.[\"deploy\", \"site-deploy\"]MAVEN_SETTINGSThe maven settings.xml file used by maven.nullMAVEN_USERNAME(DEPRECATED IN 9.38.0 ) The deploy username used to login to the repository.nullMAVEN_PASSWORD(DEPRECATED IN 9.38.0 ) The deploy password used to login to the repository.null\nNOTE: The MAVEN_USERNAME and MAVEN_PASSWORD environment variables are still supported, and have their\ncounterparts as configuration options, but should be deprecated, and will be removed in a later release. This is because\nMAVEN_SETTINGS or MAVEN_OPTIONS can do the same work, but provide a much more flexible solution."
  },
  {
    "path": [
      "Package Manager Plugins",
      "Maven Plugin",
      "Maven Project Configuration"
    ],
    "url": "docs/generated/maven#maven-project-configuration",
    "content": "\nYou will need all the following configuration blocks for all parts of auto to function:\nAuthor\n<developers>\n    <developer>\n        <name>Andrew Lisowski</name>\n        <email>test@email.com</email>\n    </developer>\n</developers>\n<developers>\n    <developer>\n        <name>Andrew Lisowski</name>\n        <email>test@email.com</email>\n    </developer>\n</developers>\n\nSCM\n<scm>\n    <connection\n  >scm:git:https://${env.GH_USER}:${env.GH_TOKEN}@github.com/Fuego-Tools/java-test-project.git</connection>\n    <developerConnection\n  >scm:git:https://${env.GH_USER}:${env.GH_TOKEN}@github.com/Fuego-Tools/java-test-project.git</developerConnection>\n    <url>https://github.com/Fuego-Tools/java-test-project</url>\n    <tag>HEAD</tag>\n</scm>\n<scm>\n    <connection\n  >scm:git:https://${env.GH_USER}:${env.GH_TOKEN}@github.com/Fuego-Tools/java-test-project.git</connection>\n    <developerConnection\n  >scm:git:https://${env.GH_USER}:${env.GH_TOKEN}@github.com/Fuego-Tools/java-test-project.git</developerConnection>\n    <url>https://github.com/Fuego-Tools/java-test-project</url>\n    <tag>HEAD</tag>\n</scm>\n\nVersions Maven Plugin RECOMMENDED (Optional)\n<plugin>\n    <groupId>org.codehaus.mojo</groupId>\n    <artifactId>versions-maven-plugin</artifactId>\n    <version>2.7</version>\n</plugin>\n<plugin>\n    <groupId>org.codehaus.mojo</groupId>\n    <artifactId>versions-maven-plugin</artifactId>\n    <version>2.7</version>\n</plugin>\n\n⚠️ Don't forget to set enviornment variables GH_USER, GH_TOKEN\nVersion\n<version>1.0.0-SNAPSHOT</version>\n<version>1.0.0-SNAPSHOT</version>\n"
  },
  {
    "path": [
      "Functionality Plugins",
      "Microsoft-Teams Plugin"
    ],
    "url": "docs/generated/microsoft-teams",
    "content": "\nPost your release notes to a Microsoft teams channel."
  },
  {
    "path": [
      "Functionality Plugins",
      "Microsoft-Teams Plugin",
      "Installation"
    ],
    "url": "docs/generated/microsoft-teams#installation",
    "content": "\nThis plugin is not included with the auto CLI installed via NPM. To install:\nnpm i --save-dev @auto-it/microsoft-teams\n# or\nyarn add -D @auto-it/microsoft-teams\nnpm i --save-dev @auto-it/microsoft-teams\n# or\nyarn add -D @auto-it/microsoft-teams\n"
  },
  {
    "path": [
      "Functionality Plugins",
      "Microsoft-Teams Plugin",
      "Usage"
    ],
    "url": "docs/generated/microsoft-teams#usage",
    "content": "\nTo use the plugin include it in your .autorc.\nTo generate incoming webhook in microsoft teams, checkout this blog.\n{\n  \"plugins\": [\n    [\"microsoft-teams\", { \"url\": \"https://url-to-your-hook.com\" }],\n    // or\n    [\"microsoft-teams\", \"https://url-to-your-hook.com\"],\n    // or\n    [\n      \"microsoft-teams\",\n      { \"url\": \"https://url-to-your--hook.com\", \"atTarget\": \"username\" }\n    ]\n    // Below: Uses microsoft-teams hook set in process.env.MICROSOFT_TEAMS_WEBHOOK_URL\n    \"microsoft-teams\"\n  ]\n}\n{\n  \"plugins\": [\n    [\"microsoft-teams\", { \"url\": \"https://url-to-your-hook.com\" }],\n    // or\n    [\"microsoft-teams\", \"https://url-to-your-hook.com\"],\n    // or\n    [\n      \"microsoft-teams\",\n      { \"url\": \"https://url-to-your--hook.com\", \"atTarget\": \"username\" }\n    ]\n    // Below: Uses microsoft-teams hook set in process.env.MICROSOFT_TEAMS_WEBHOOK_URL\n    \"microsoft-teams\"\n  ]\n}\n"
  },
  {
    "path": [
      "Publishing",
      "next"
    ],
    "url": "docs/generated/next",
    "content": "\nMake a release for your \"prerelease\" release line. This is ran automatically by \"shipit\" in a prerelease branch.\nCreates a prerelease on package management platformCreates a \"Pre Release\" on GitHub releases pageIf ran from a PR build in a CI, posts the prerelease's full releases notes and expected version of the prerelease\nCalling the next command from a prerelease branch will publish a prerelease for just that branch, otherwise it will publish to the default prerelease branch."
  },
  {
    "path": [
      "Publishing",
      "next",
      "Options"
    ],
    "url": "docs/generated/next#options",
    "content": "\nFlagTypeDescription--dry-run, -dBooleanReport what command will do but do not actually do anything--message, -mStringThe message used when attaching the prerelease version to a PR--forceBooleanForce a canary release, even if the PR is marked to skip the release--quiet, -qBooleanPrint only the result of the command"
  },
  {
    "path": [
      "Publishing",
      "next",
      "Examples"
    ],
    "url": "docs/generated/next#examples",
    "content": "\nauto next\nauto next\n"
  },
  {
    "path": [
      "Publishing",
      "next",
      "Configurable Options"
    ],
    "url": "docs/generated/next#configurable-options",
    "content": "\nYou can configure some of the options for the next command in the .autorc.\nmessageforce\nExample .autorc:\n{\n  \"next\": {\n    \"message\": \"string\",\n    \"force\": true\n  }\n}\n{\n  \"next\": {\n    \"message\": \"string\",\n    \"force\": true\n  }\n}\n"
  },
  {
    "path": [
      "Publishing",
      "next",
      "Configurable Options",
      "Setting up Protected Branches"
    ],
    "url": "docs/generated/next#setting-up-protected-branches",
    "content": "\nYou should make your pre-release branches protected on GitHub. This will prevent a bunch of unwanted behavior from happening.\nGo to you project's setting on GitHubClick BranchesClick Add RuleEnter the name of your prerelease branch (ex: next)Configure extra branch protection settings(Optional) Set the base branch in GitHub to your prerelease branch (this ensure new PRs go to this branch)"
  },
  {
    "path": [
      "Package Manager Plugins",
      "NPM Plugin"
    ],
    "url": "docs/generated/npm",
    "content": "\nPublish to NPM.\nWorks in both a monorepo setting and for a single package.\nThis plugin is loaded by default when auto is installed through npm.\nIf you configure auto to use any other plugin this will be lost.\nSo you must add the npm plugin to your plugins array if you still want NPM functionality."
  },
  {
    "path": [
      "Package Manager Plugins",
      "NPM Plugin",
      "Prerequisites"
    ],
    "url": "docs/generated/npm#prerequisites",
    "content": "\nTo publish to npm you will need an NPM_TOKEN set in your environment.\nWarning! Avoid using the prepublishOnly script as it can lead to errors. Read more here."
  },
  {
    "path": [
      "Package Manager Plugins",
      "NPM Plugin",
      "Installation"
    ],
    "url": "docs/generated/npm#installation",
    "content": "\nThis plugin is included with the auto CLI so you do not have to install it. To install if you are using the auto API directly:\nnpm i --save-dev @auto-it/npm\n# or\nyarn add -D @auto-it/npm\nnpm i --save-dev @auto-it/npm\n# or\nyarn add -D @auto-it/npm\n\nWARNING: You can only use one \"package manager\" at a time!\nMixing them will lead to undesired results."
  },
  {
    "path": [
      "Package Manager Plugins",
      "NPM Plugin",
      "Usage"
    ],
    "url": "docs/generated/npm#usage",
    "content": "\n{\n  \"plugins\": [\n    \"npm\",\n    // or with options\n    [\"npm\", { \"forcePublish\": false }]\n    // other plugins\n  ]\n}\n{\n  \"plugins\": [\n    \"npm\",\n    // or with options\n    [\"npm\", { \"forcePublish\": false }]\n    // other plugins\n  ]\n}\n\nIf you're using the noVersionPrefix option you will also need to add tag-version-prefix=\"\" to your .npmrc.\nOtherwise when npm versions your code the tag it creates will have the v and auto will get confused."
  },
  {
    "path": [
      "Package Manager Plugins",
      "NPM Plugin",
      "Monorepo Usage"
    ],
    "url": "docs/generated/npm#monorepo-usage",
    "content": "\nThe npm plugin works out of the box with lerna in both independent and fixed mode.\nauto works on a repo basis and should be run from the root of the repo, not on each sub-package.\nNo additional setup is required.\nDo you have a package in your monorepo you don't want to publish but still want versioned?\nJust set that \"private\": true you that package's package.json!"
  },
  {
    "path": [
      "Package Manager Plugins",
      "NPM Plugin",
      "Monorepo Usage",
      "Using automation tokens from NPM"
    ],
    "url": "docs/generated/npm#using-automation-tokens-from-npm",
    "content": "\nIf you have 2FA enabled and want to publish using an automation token you must add the following to your lerna.json for it to work.\n{\n  // ... other config here\n  \"command\": {\n    \"publish\": {\n      \"verifyAccess\": false\n    }\n  }\n}\n{\n  // ... other config here\n  \"command\": {\n    \"publish\": {\n      \"verifyAccess\": false\n    }\n  }\n}\n\nLerna's verify access step hits an npm api endpoint that treats automation tokens differently than regular user tokens. Disabling it will bypass that failure. See this lerna issue for more context."
  },
  {
    "path": [
      "Package Manager Plugins",
      "NPM Plugin",
      "Options"
    ],
    "url": "docs/generated/npm#options",
    "content": ""
  },
  {
    "path": [
      "Package Manager Plugins",
      "NPM Plugin",
      "Options",
      "setRcToken"
    ],
    "url": "docs/generated/npm#setrctoken",
    "content": "\nWhen running the shipit command auto will try to set your .npmrc token while publishing. To disable this feature you must set the setRcToken to false.\n{\n  \"plugins\": [\n    [\n      \"npm\",\n      {\n        \"setRcToken\": false\n      }\n    ]\n  ]\n}\n{\n  \"plugins\": [\n    [\n      \"npm\",\n      {\n        \"setRcToken\": false\n      }\n    ]\n  ]\n}\n"
  },
  {
    "path": [
      "Package Manager Plugins",
      "NPM Plugin",
      "Options",
      "forcePublish"
    ],
    "url": "docs/generated/npm#forcepublish",
    "content": "\nBy default auto will force publish all packages for monorepos. To disable this behavior you must set the forcePublish to false.\n{\n  \"plugins\": [\n    [\n      \"npm\",\n      {\n        \"forcePublish\": false\n      }\n    ]\n  ]\n}\n{\n  \"plugins\": [\n    [\n      \"npm\",\n      {\n        \"forcePublish\": false\n      }\n    ]\n  ]\n}\n"
  },
  {
    "path": [
      "Package Manager Plugins",
      "NPM Plugin",
      "Options",
      "exact"
    ],
    "url": "docs/generated/npm#exact",
    "content": "\nTo force all packages publish with exact versions.\n{\n  \"plugins\": [\n    [\n      \"npm\",\n      {\n        \"exact\": true\n      }\n    ]\n  ]\n}\n{\n  \"plugins\": [\n    [\n      \"npm\",\n      {\n        \"exact\": true\n      }\n    ]\n  ]\n}\n"
  },
  {
    "path": [
      "Package Manager Plugins",
      "NPM Plugin",
      "Options",
      "subPackageChangelogs"
    ],
    "url": "docs/generated/npm#subpackagechangelogs",
    "content": "\nauto will create a changelog for each sub-package in a monorepo.\nYou can disable this behavior by using the subPackageChangelogs option.\n{\n  \"plugins\": [\n    [\n      \"npm\",\n      {\n        \"subPackageChangelogs\": false\n      }\n    ]\n  ]\n}\n{\n  \"plugins\": [\n    [\n      \"npm\",\n      {\n        \"subPackageChangelogs\": false\n      }\n    ]\n  ]\n}\n"
  },
  {
    "path": [
      "Package Manager Plugins",
      "NPM Plugin",
      "Options",
      "monorepoChangelog"
    ],
    "url": "docs/generated/npm#monorepochangelog",
    "content": "\nauto will group changelog lines by sub-packages in a monorepo.\nYou can disable this behavior by using the monorepoChangelog option.\n{\n  \"plugins\": [\n    [\n      \"npm\",\n      {\n        \"monorepoChangelog\": false\n      }\n    ]\n  ]\n}\n{\n  \"plugins\": [\n    [\n      \"npm\",\n      {\n        \"monorepoChangelog\": false\n      }\n    ]\n  ]\n}\n"
  },
  {
    "path": [
      "Package Manager Plugins",
      "NPM Plugin",
      "Options",
      "commitNextVersion"
    ],
    "url": "docs/generated/npm#commitnextversion",
    "content": "\nWhether to create a commit for \"next\" version.\nThe default behavior will only create the tags.\n{\n  \"plugins\": [\n    [\n      \"npm\",\n      {\n        \"commitNextVersion\": true\n      }\n    ]\n  ]\n}\n{\n  \"plugins\": [\n    [\n      \"npm\",\n      {\n        \"commitNextVersion\": true\n      }\n    ]\n  ]\n}\n"
  },
  {
    "path": [
      "Package Manager Plugins",
      "NPM Plugin",
      "Options",
      "legacyAuth"
    ],
    "url": "docs/generated/npm#legacyauth",
    "content": "\nWhen publishing packages that require authentication but you are working with an internally hosted npm registry that only uses the legacy Base64 version of username:password.\nThis is the same as the NPM publish _auth flag.\nFor security this option only accepts a boolean.\nWhen this option is set true auto will pass --_auth $NPM_TOKEN to the publish command.\nSet $NPM_TOKEN to the \"Base64 version of username:password\".\n{\n  \"plugins\": [\n    [\n      \"npm\",\n      {\n        \"legacyAuth\": true\n      }\n    ]\n  ]\n}\n{\n  \"plugins\": [\n    [\n      \"npm\",\n      {\n        \"legacyAuth\": true\n      }\n    ]\n  ]\n}\n"
  },
  {
    "path": [
      "Package Manager Plugins",
      "NPM Plugin",
      "Options",
      "canaryScope"
    ],
    "url": "docs/generated/npm#canaryscope",
    "content": "\nPublishing canary versions comes with some security risks.\nIf your project is private you have nothing to worry about and can skip these, but if your project is open source there are some security holes.\n⚠️ This feature works pretty easily/well for single packages. In a monorepo we have to deal with a lot more, and this options should be treated as experimental."
  },
  {
    "path": [
      "Package Manager Plugins",
      "NPM Plugin",
      "Options",
      "canaryScope",
      "Setup"
    ],
    "url": "docs/generated/npm#setup",
    "content": "\nCreate a test scope that you publish canaries under (ex: @auto-canary or @auto-test)Create a user that only has access to that scopeSet the default NPM_TOKEN to a token that can publish to that scope (this is used for any pull request)Set up a secure token that is only accessible on the main fork (still named NPM_TOKEN)Set up alias (only monorepos)\nStep 3 might not be possible on your build platform.\nThe following are the ways the auto team knows how to do it.\nIf you do not see the method for you build platform, please make a pull request!\nPlatform Solutions:\nCircleCI Context - Contexts provide a mechanism for securing and sharing environment variables across projects. The environment variables are defined as name/value pairs and are injected at runtime.\n{\n  \"plugins\": [\n    [\n      \"npm\",\n      {\n        \"canaryScope\": \"@auto-canary\"\n      }\n    ]\n  ]\n}\n{\n  \"plugins\": [\n    [\n      \"npm\",\n      {\n        \"canaryScope\": \"@auto-canary\"\n      }\n    ]\n  ]\n}\n"
  },
  {
    "path": [
      "Package Manager Plugins",
      "NPM Plugin",
      "Options",
      "canaryScope",
      "Setup",
      "Set up alias"
    ],
    "url": "docs/generated/npm#set-up-alias",
    "content": "\nIf you are managing a non-monorepo you do not have to do anything for this step!\nIf you manage a monorepo we still have to do handle our packages importing each other.\nSince we just changed the name of the package all imports to our packages are now broken!\nThere are multiple ways to make this work and the solution might be different depending on your build target.\nmodule-alias - Modifiy node's require for your canary deploys (This is what auto uses). Useful for node packagesWebpack Aliases Modify scoped requires for webpack based projects.babel-plugin-module-resolver - A Babel plugin to add a new resolver for your modules when compiling your code using Babel."
  },
  {
    "path": [
      "Package Manager Plugins",
      "NPM Plugin",
      "Troubleshooting"
    ],
    "url": "docs/generated/npm#troubleshooting",
    "content": ""
  },
  {
    "path": [
      "Package Manager Plugins",
      "NPM Plugin",
      "npm ERR! need auth auth required for publishing"
    ],
    "url": "docs/generated/npm#npm-err-need-auth-auth-required-for-publishing",
    "content": "\nThis error will occur when you do not have a NPM_TOKEN set."
  },
  {
    "path": [
      "Package Manager Plugins",
      "NPM Plugin",
      "npm ERR! need auth auth required for publishing",
      "Still getting errors?!"
    ],
    "url": "docs/generated/npm#still-getting-errors",
    "content": "\nMake sure that npm is trying to publish to the correct registry. Force npm/lerna to use the public registry by adding the following to your package.json:\n{\n  \"publishConfig\": {\n    \"registry\": \"https://registry.npmjs.org/\",\n    \"access\": \"public\"\n  }\n}\n{\n  \"publishConfig\": {\n    \"registry\": \"https://registry.npmjs.org/\",\n    \"access\": \"public\"\n  }\n}\n"
  },
  {
    "path": [
      "Functionality Plugins",
      "Omit Commits Plugin"
    ],
    "url": "docs/generated/omit-commits",
    "content": "\nFilter certain commits out of the changelog and version calculation."
  },
  {
    "path": [
      "Functionality Plugins",
      "Omit Commits Plugin",
      "Installation"
    ],
    "url": "docs/generated/omit-commits#installation",
    "content": "\nThis plugin is not included with the auto CLI installed via NPM. To install:\nnpm i --save-dev @auto-it/omit-commits\n# or\nyarn add -D @auto-it/omit-commits\nnpm i --save-dev @auto-it/omit-commits\n# or\nyarn add -D @auto-it/omit-commits\n"
  },
  {
    "path": [
      "Functionality Plugins",
      "Omit Commits Plugin",
      "Usage"
    ],
    "url": "docs/generated/omit-commits#usage",
    "content": "\nYarn can omit by most any field available on a commit. Each options accepts either a string or an array of strings.\n{\n  \"plugins\": [\n    [\n      \"omit-commits\",\n      {\n        // By usernames\n        \"username\": [\"pdbf\", \"ghost\"],\n        // By name\n        \"name\": \"Adam\",\n        // By emails\n        \"email\": [\"foo@gmail.com\", \"doesnt-exits@yahoo.com\"],\n        // By presence of string in subject\n        \"subject\": [\"WIP\", \"SPIKE\"],\n        // By labels\n        \"labels\": \"grunt-work\"\n      }\n    ]\n  ]\n}\n{\n  \"plugins\": [\n    [\n      \"omit-commits\",\n      {\n        // By usernames\n        \"username\": [\"pdbf\", \"ghost\"],\n        // By name\n        \"name\": \"Adam\",\n        // By emails\n        \"email\": [\"foo@gmail.com\", \"doesnt-exits@yahoo.com\"],\n        // By presence of string in subject\n        \"subject\": [\"WIP\", \"SPIKE\"],\n        // By labels\n        \"labels\": \"grunt-work\"\n      }\n    ]\n  ]\n}\n"
  },
  {
    "path": [
      "Functionality Plugins",
      "Omit Release Notes Plugin"
    ],
    "url": "docs/generated/omit-release-notes",
    "content": "\nFilter PRs with release notes that shouldn't make it into a release. By default auto will not include and Release Notes from renovate PRs. This plugin allows you to omit more PRs from effecting you releases."
  },
  {
    "path": [
      "Functionality Plugins",
      "Omit Release Notes Plugin",
      "Installation"
    ],
    "url": "docs/generated/omit-release-notes#installation",
    "content": "\nThis plugin is not included with the auto CLI installed via NPM. To install:\nnpm i --save-dev @auto-it/omit-release-notes\n# or\nyarn add -D @auto-it/omit-release-notes\nnpm i --save-dev @auto-it/omit-release-notes\n# or\nyarn add -D @auto-it/omit-release-notes\n"
  },
  {
    "path": [
      "Functionality Plugins",
      "Omit Release Notes Plugin",
      "Usage"
    ],
    "url": "docs/generated/omit-release-notes#usage",
    "content": "\nYarn can omit by most any field available on a PR. Each options accepts either a string or an array of strings.\n{\n  \"plugins\": [\n    [\n      \"omit-release-notes\",\n      {\n        // By usernames\n        \"username\": [\"pdbf\", \"ghost\"],\n        // By name\n        \"name\": \"Adam\",\n        // By emails\n        \"email\": [\"foo@gmail.com\", \"doesnt-exits@yahoo.com\"],\n        // By labels\n        \"labels\": \"grunt-work\"\n      }\n    ]\n  ]\n}\n{\n  \"plugins\": [\n    [\n      \"omit-release-notes\",\n      {\n        // By usernames\n        \"username\": [\"pdbf\", \"ghost\"],\n        // By name\n        \"name\": \"Adam\",\n        // By emails\n        \"email\": [\"foo@gmail.com\", \"doesnt-exits@yahoo.com\"],\n        // By labels\n        \"labels\": \"grunt-work\"\n      }\n    ]\n  ]\n}\n"
  },
  {
    "path": [
      "Functionality Plugins",
      "Pr-Body-Labels Plugin"
    ],
    "url": "docs/generated/pr-body-labels",
    "content": "\nAllow outside contributors to indicate what semver label should be applied to the Pull Request.\nIf you run auto pr-check from your CI this plugin will look at the PR body to find what label to apply."
  },
  {
    "path": [
      "Functionality Plugins",
      "Pr-Body-Labels Plugin",
      "Installation"
    ],
    "url": "docs/generated/pr-body-labels#installation",
    "content": "\nThis plugin is not included with the auto CLI installed via NPM. To install:\nnpm i --save-dev @auto-it/pr-body-labels\n# or\nyarn add -D @auto-it/pr-body-labels\nnpm i --save-dev @auto-it/pr-body-labels\n# or\nyarn add -D @auto-it/pr-body-labels\n"
  },
  {
    "path": [
      "Functionality Plugins",
      "Pr-Body-Labels Plugin",
      "Usage"
    ],
    "url": "docs/generated/pr-body-labels#usage",
    "content": "\n{\n  \"plugins\": [\n    [\"pr-body-labels\"]\n    // other plugins\n  ]\n}\n{\n  \"plugins\": [\n    [\"pr-body-labels\"]\n    // other plugins\n  ]\n}\n\nThen something like the following to your .github/PULL_REQUEST_TEMPLATE.md.\nThe only part of this that really matters is a markdown checkbox + one of your labels.\nYou control what labels an outside contributor can apply through the PR body.\nThis example only exposes the semantic versioning labels but you can include any label in your project.\n## Change Type\n\nIndicate the type of change your pull request is:\n\n- [ ] `patch`\n- [ ] `minor`\n- [ ] `major`\n## Change Type\n\nIndicate the type of change your pull request is:\n\n- [ ] `patch`\n- [ ] `minor`\n- [ ] `major`\n"
  },
  {
    "path": [
      "Functionality Plugins",
      "Pr-Body-Labels Plugin",
      "Options"
    ],
    "url": "docs/generated/pr-body-labels#options",
    "content": ""
  },
  {
    "path": [
      "Functionality Plugins",
      "Pr-Body-Labels Plugin",
      "Options",
      "disabledLabels"
    ],
    "url": "docs/generated/pr-body-labels#disabledlabels",
    "content": "\nLabels the user cannot apply through the PR.\n{\n  \"plugins\": [[\"pr-body-labels\", { \"disabledLabels\": [\"release\"] }]]\n}\n{\n  \"plugins\": [[\"pr-body-labels\", { \"disabledLabels\": [\"release\"] }]]\n}\n"
  },
  {
    "path": [
      "PR Interaction",
      "pr-body"
    ],
    "url": "docs/generated/pr-body",
    "content": "\nUpdate the body of a PR with a message. Appends to PR and will not overwrite user content. Each comment has a context, and each context only has one comment."
  },
  {
    "path": [
      "PR Interaction",
      "pr-body",
      "Options"
    ],
    "url": "docs/generated/pr-body#options",
    "content": "\nFlagTypeDescription--prNumberThe pull request the command should use. Detects PR number in CI--contextStringA string label to differentiate this status from others--message, -mStringMessage to post to PR body--dry-run, -dBooleanReport what command will do but do not actually do anything"
  },
  {
    "path": [
      "PR Interaction",
      "pr-body",
      "Examples"
    ],
    "url": "docs/generated/pr-body#examples",
    "content": "\nauto pr-body --delete\nauto pr-body --delete\n\nauto pr-body --pr 123 --comment \"The new version is: 1.2.3\"\nauto pr-body --pr 123 --comment \"The new version is: 1.2.3\"\n"
  },
  {
    "path": [
      "PR Interaction",
      "pr-check"
    ],
    "url": "docs/generated/pr-check",
    "content": "\nCheck that a pull request has a SemVer label and run all pr-check plugins."
  },
  {
    "path": [
      "PR Interaction",
      "pr-check",
      "Options"
    ],
    "url": "docs/generated/pr-check#options",
    "content": "\nFlagTypeDescription--prNumberThe pull request the command should use. Detects PR number in CI--urlStringURL to associate with this status--dry-run, -dBooleanReport what command will do but do not actually do anything--contextStringA string label to differentiate this status from others"
  },
  {
    "path": [
      "PR Interaction",
      "pr-check",
      "Examples"
    ],
    "url": "docs/generated/pr-check#examples",
    "content": "\nauto pr-check --url http://your-ci.com/build/123\nauto pr-check --url http://your-ci.com/build/123\n"
  },
  {
    "path": [
      "PR Interaction",
      "pr-status"
    ],
    "url": "docs/generated/pr-status",
    "content": "\nSet the status on a PR commit"
  },
  {
    "path": [
      "PR Interaction",
      "pr-status",
      "Options"
    ],
    "url": "docs/generated/pr-status#options",
    "content": "\nFlagTypeDescription--shaStringSpecify a custom git sha. Defaults to the HEAD for a git repo in the current repository--prNumberPR to set the status on. Detects PR number in CI--urlStringURL to associate with this status--stateStringState of the PR. ['pending', 'success', 'error', 'failure']--descriptionStringA description of the status--contextStringA string label to differentiate this status from others--dry-run, -dBooleanReport what command will do but do not actually do anything"
  },
  {
    "path": [
      "PR Interaction",
      "pr-status",
      "Examples"
    ],
    "url": "docs/generated/pr-status#examples",
    "content": "\nauto pr-status \\\\ \n   --state pending \\\\ \n   --description \"Build still running...\" \\\\ \n   --context build-check\nauto pr-status \\\\ \n   --state pending \\\\ \n   --description \"Build still running...\" \\\\ \n   --context build-check\n"
  },
  {
    "path": [
      "Publishing",
      "release"
    ],
    "url": "docs/generated/release",
    "content": "\nCreate a GitHub release for a tag. Defaults to last tag in branch.\nNOTE: The tag must already be pushed to GitHub. If it isn't GitHub will create a tag pointing to the \"to\" option value."
  },
  {
    "path": [
      "Publishing",
      "release",
      "Options"
    ],
    "url": "docs/generated/release#options",
    "content": "\nFlagTypeDescription--dry-run, -dBooleanReport what command will do but do not actually do anything--no-version-prefixBooleanUse the version as the tag without the 'v' prefix. WARNING: some plugins might need extra config to use this option (ex: npm)--nameStringGit name to commit  with. Defaults to package definition for the platform--emailStringGit email to commit with. Defaults to package definition for the platform--fromStringGit revision (tag, commit sha, ...) to start release notes from. Defaults to latest tag.--toStringGit revision (tag, commit sha, ...) to end release notes at. Defaults to HEAD.--use-versionStringVersion number to publish as. Defaults to reading from the package definition for the platform.--base-branchStringBranch to treat as the base branch--prereleaseBooleanPublish a prerelease on GitHub."
  },
  {
    "path": [
      "Publishing",
      "release",
      "Examples"
    ],
    "url": "docs/generated/release#examples",
    "content": "\nauto release\nauto release\n\nThis command can be used in isolation easily. This example will: tag the release version at 'to' and create a GitHub release changelog over the commits range\nauto release --from v0.20.1 --to HEAD --use-version v0.21.0\nauto release --from v0.20.1 --to HEAD --use-version v0.21.0\n"
  },
  {
    "path": [
      "Publishing",
      "release",
      "Configurable Options"
    ],
    "url": "docs/generated/release#configurable-options",
    "content": "\nYou can configure some of the options for the release command in the .autorc.\nprerelease\nExample .autorc:\n{\n  \"release\": {\n    \"prerelease\": true\n  }\n}\n{\n  \"release\": {\n    \"prerelease\": true\n  }\n}\n\n⚠️ Make sure you give the GH_TOKEN repo permission or release will fail!"
  },
  {
    "path": [
      "Publishing",
      "release",
      "Usage"
    ],
    "url": "docs/generated/release#usage",
    "content": "\n{\n  \"scripts\": {\n    \"postpublish\": \"auto release\"\n  }\n}\n{\n  \"scripts\": {\n    \"postpublish\": \"auto release\"\n  }\n}\n\nMake sure the branch/tag you're releasing is on github before running auto release.\nYou will need to push the tags to github first:\n{\n  \"scripts\": {\n    \"postpublish\": \"git push --follow-tags --set-upstream origin $branch && auto release\"\n  }\n}\n{\n  \"scripts\": {\n    \"postpublish\": \"git push --follow-tags --set-upstream origin $branch && auto release\"\n  }\n}\n"
  },
  {
    "path": [
      "Publishing",
      "release",
      "Github Release Details"
    ],
    "url": "docs/generated/release#github-release-details",
    "content": "\nThe details / description published with the Github release will be identical to those generated by the auto changelog command.\nSee information regarding the release note format here."
  },
  {
    "path": [
      "Functionality Plugins",
      "Released Plugin"
    ],
    "url": "docs/generated/released",
    "content": "\nThis plugin\ncomments on the merged PR with the new versioncomments on closed issues with the new versionadds a released label to the pull requestadds a released label to closed issues\n⚠️ Make sure that you create the released label on you project"
  },
  {
    "path": [
      "Functionality Plugins",
      "Released Plugin",
      "Installation"
    ],
    "url": "docs/generated/released#installation",
    "content": "\nThis plugin is included with the auto CLI so you do not have to install it. To install if you are using the auto API directly:\nnpm i --save-dev @auto-it/released\n# or\nyarn add -D @auto-it/released\nnpm i --save-dev @auto-it/released\n# or\nyarn add -D @auto-it/released\n"
  },
  {
    "path": [
      "Functionality Plugins",
      "Released Plugin",
      "Usage"
    ],
    "url": "docs/generated/released#usage",
    "content": "\nTo use the plugin include it in your .autorc\n{\n  \"plugins\": [\"released\"]\n}\n{\n  \"plugins\": [\"released\"]\n}\n"
  },
  {
    "path": [
      "Functionality Plugins",
      "Released Plugin",
      "Options"
    ],
    "url": "docs/generated/released#options",
    "content": ""
  },
  {
    "path": [
      "Functionality Plugins",
      "Released Plugin",
      "Options",
      "Label"
    ],
    "url": "docs/generated/released#label",
    "content": "\nCustomize the label this plugin attaches to merged pull requests.\n{\n  \"plugins\": [\n    [\n      \"released\",\n      {\n        \"label\": \":shipit:\"\n      }\n    ]\n  ]\n}\n{\n  \"plugins\": [\n    [\n      \"released\",\n      {\n        \"label\": \":shipit:\"\n      }\n    ]\n  ]\n}\n"
  },
  {
    "path": [
      "Functionality Plugins",
      "Released Plugin",
      "Options",
      "Prerelease Label"
    ],
    "url": "docs/generated/released#prerelease-label",
    "content": "\nCustomize the prerelease label this plugin attaches to pull requests merged to prerelease branches.\n{\n  \"plugins\": [\n    [\n      \"released\",\n      {\n        \"prereleaseLabel\": \"🚧\"\n      }\n    ]\n  ]\n}\n{\n  \"plugins\": [\n    [\n      \"released\",\n      {\n        \"prereleaseLabel\": \"🚧\"\n      }\n    ]\n  ]\n}\n"
  },
  {
    "path": [
      "Functionality Plugins",
      "Released Plugin",
      "Options",
      "Message"
    ],
    "url": "docs/generated/released#message",
    "content": "\nTo customize the message this plugin uses on issues and pull requests use the following format.\n%TYPE - Either PR or Issue%VERSION - The version that was just published\n{\n  \"plugins\": [\n    [\n      \"released\",\n      {\n        \"message\": \"%TYPE went out with version: %VERSION\"\n      }\n    ]\n  ]\n}\n{\n  \"plugins\": [\n    [\n      \"released\",\n      {\n        \"message\": \"%TYPE went out with version: %VERSION\"\n      }\n    ]\n  ]\n}\n"
  },
  {
    "path": [
      "Functionality Plugins",
      "Released Plugin",
      "Options",
      "Lock Issue"
    ],
    "url": "docs/generated/released#lock-issue",
    "content": "\nLock issues that have been merged in PRs.\n{\n  \"plugins\": [[\"released\", { \"lockIssues\": true }]]\n}\n{\n  \"plugins\": [[\"released\", { \"lockIssues\": true }]]\n}\n"
  },
  {
    "path": [
      "Functionality Plugins",
      "Released Plugin",
      "Options",
      "Include Bot Prs"
    ],
    "url": "docs/generated/released#include-bot-prs",
    "content": "\nWhether to comment on PRs made by bots.\n{\n  \"plugins\": [[\"released\", { \"includeBotPrs\": true }]]\n}\n{\n  \"plugins\": [[\"released\", { \"includeBotPrs\": true }]]\n}\n"
  },
  {
    "path": [
      "Functionality Plugins",
      "S3 Plugin"
    ],
    "url": "docs/generated/s3",
    "content": "\nPost your built artifacts to s3."
  },
  {
    "path": [
      "Functionality Plugins",
      "S3 Plugin",
      "Prerequisites"
    ],
    "url": "docs/generated/s3#prerequisites",
    "content": "\nMust have the aws-cli on your machine and all of the following environment variables set:\nAWS_ACCESS_KEYAWS_SECRET_KEYAWS_SESSION_TOKEN"
  },
  {
    "path": [
      "Functionality Plugins",
      "S3 Plugin",
      "Installation"
    ],
    "url": "docs/generated/s3#installation",
    "content": "\nThis plugin is not included with the auto CLI installed via NPM. To install:\nnpm i --save-dev @auto-it/s3\n# or\nyarn add -D @auto-it/s3\nnpm i --save-dev @auto-it/s3\n# or\nyarn add -D @auto-it/s3\n"
  },
  {
    "path": [
      "Functionality Plugins",
      "S3 Plugin",
      "Usage"
    ],
    "url": "docs/generated/s3#usage",
    "content": "\nPublish a single asset to s3.\nbucket: Bucket to deploy to\nregion: Region to deploy to\nfiles: An array of tuples mapping local build files to remote deploy paths.\nEX:\n\ngiven: `[[\"components/button/dist\", \"components/button\"]]`\n\n=> Deploy the files in \"components/button/dist\" to s3://bucket/components/button on `region`\nEX:\n\ngiven: `[[\"components/button/dist\", \"components/button\"]]`\n\n=> Deploy the files in \"components/button/dist\" to s3://bucket/components/button on `region`\n\nFull:\n{\n  \"plugins\": [\n    [\n      \"s3\",\n      {\n        \"bucket\": \"BUCKET_NAME\",\n        \"region\": \"REGION_NAME\",\n        \"files\": [[\"components/button/dist\", \"components/button\"]]\n      }\n    ]\n    // other plugins\n  ]\n}\n{\n  \"plugins\": [\n    [\n      \"s3\",\n      {\n        \"bucket\": \"BUCKET_NAME\",\n        \"region\": \"REGION_NAME\",\n        \"files\": [[\"components/button/dist\", \"components/button\"]]\n      }\n    ]\n    // other plugins\n  ]\n}\n"
  },
  {
    "path": [
      "Functionality Plugins",
      "S3 Plugin",
      "Usage",
      "Versioning Deploys"
    ],
    "url": "docs/generated/s3#versioning-deploys",
    "content": "\nTo version your deployed assets simply add $VERSION in the remote path. This will be replaced with the new version being released.\n{\n  \"plugins\": [\n    [\n      \"s3\",\n      {\n        \"bucket\": \"BUCKET_NAME\",\n        \"region\": \"REGION_NAME\",\n        \"files\": [[\"components/button/dist\", \"$VERSION/components/button\"]]\n      }\n    ]\n    // other plugins\n  ]\n}\n{\n  \"plugins\": [\n    [\n      \"s3\",\n      {\n        \"bucket\": \"BUCKET_NAME\",\n        \"region\": \"REGION_NAME\",\n        \"files\": [[\"components/button/dist\", \"$VERSION/components/button\"]]\n      }\n    ]\n    // other plugins\n  ]\n}\n"
  },
  {
    "path": [
      "Functionality Plugins",
      "S3 Plugin",
      "Usage",
      "Multiple Files"
    ],
    "url": "docs/generated/s3#multiple-files",
    "content": "\nPublish multiple assets to s3.\n{\n  \"plugins\": [\n    [\n      \"s3\",\n      {\n        \"bucket\": \"BUCKET_NAME\",\n        \"region\": \"REGION_NAME\",\n        \"files\": [\n          [\"components/button/dist\", \"components/button\"],\n          [\"components/card/dist\", \"components/card\"],\n          [\"components/select/dist\", \"components/select\"]\n        ]\n      }\n    ]\n  ]\n}\n{\n  \"plugins\": [\n    [\n      \"s3\",\n      {\n        \"bucket\": \"BUCKET_NAME\",\n        \"region\": \"REGION_NAME\",\n        \"files\": [\n          [\"components/button/dist\", \"components/button\"],\n          [\"components/card/dist\", \"components/card\"],\n          [\"components/select/dist\", \"components/select\"]\n        ]\n      }\n    ]\n  ]\n}\n"
  },
  {
    "path": [
      "Functionality Plugins",
      "S3 Plugin",
      "Usage",
      "Multiple Buckets"
    ],
    "url": "docs/generated/s3#multiple-buckets",
    "content": "\nPublish assets to multiple s3 buckets.\n{\n  \"plugins\": [\n    [\n      \"s3\",\n      [\n        {\n          \"bucket\": \"BUCKET_NAME\",\n          \"region\": \"REGION_NAME\",\n          \"files\": [[\"components/button/dist\", \"components/button\"]]\n        },\n        {\n          \"bucket\": \"ANOTHER_BUCKET_NAME\",\n          \"region\": \"REGION_NAME\",\n          \"files\": [[\"components/card/dist\", \"components/card\"]]\n        }\n      ]\n    ]\n  ]\n}\n{\n  \"plugins\": [\n    [\n      \"s3\",\n      [\n        {\n          \"bucket\": \"BUCKET_NAME\",\n          \"region\": \"REGION_NAME\",\n          \"files\": [[\"components/button/dist\", \"components/button\"]]\n        },\n        {\n          \"bucket\": \"ANOTHER_BUCKET_NAME\",\n          \"region\": \"REGION_NAME\",\n          \"files\": [[\"components/card/dist\", \"components/card\"]]\n        }\n      ]\n    ]\n  ]\n}\n"
  },
  {
    "path": [
      "Functionality Plugins",
      "S3 Plugin",
      "Usage",
      "Overwrite"
    ],
    "url": "docs/generated/s3#overwrite",
    "content": "\nBy default this plugin will overwrite any bucket path you give it. To prevent it from overwriting your bucket path if it already exists set overwrite to false\n{\n  \"plugins\": [\n    [\n      \"s3\",\n      {\n        \"bucket\": \"BUCKET_NAME\",\n        \"region\": \"REGION_NAME\",\n        \"overwrite\": false,\n        ...\n      }\n    ]\n  ]\n}\n{\n  \"plugins\": [\n    [\n      \"s3\",\n      {\n        \"bucket\": \"BUCKET_NAME\",\n        \"region\": \"REGION_NAME\",\n        \"overwrite\": false,\n        ...\n      }\n    ]\n  ]\n}\n"
  },
  {
    "path": [
      "Publishing",
      "shipit"
    ],
    "url": "docs/generated/shipit",
    "content": "\nContext aware publishing.\ncall from base branch -> latest version released (LATEST)call from prerelease branch -> prerelease version released (NEXT)call from PR in CI -> canary version released (CANARY)call locally when not on base/prerelease branch -> canary version released (CANARY)"
  },
  {
    "path": [
      "Publishing",
      "shipit",
      "Options"
    ],
    "url": "docs/generated/shipit#options",
    "content": "\nFlagTypeDescription--nameStringGit name to commit  with. Defaults to package definition for the platform--emailStringGit email to commit with. Defaults to package definition for the platform--only-publish-with-release-labelBooleanOnly bump version if 'release' label is on pull request--base-branchStringBranch to treat as the base branch--dry-run, -dBooleanReport what command will do but do not actually do anything--no-version-prefixBooleanUse the version as the tag without the 'v' prefix. WARNING: some plugins might need extra config to use this option (ex: npm)--prereleaseBooleanPublish a prerelease on GitHub.--titleStringOverride the title used in the addition to the CHANGELOG.md.--message, -mStringMessage to commit the changelog with. Defaults to 'Update CHANGELOG.md [skip ci]'--quiet, -qBooleanPrint only the result of the command--no-changelogBooleanSkip creating the changelog--only-graduate-with-release-labelBooleanMake auto publish prerelease versions when merging to baseBranch. Only PRs merged with \"release\" label will generate a \"latest\" release. Only use this flag if you do not want to maintain a prerelease branch, and instead only want to use baseBranch."
  },
  {
    "path": [
      "Publishing",
      "shipit",
      "Examples"
    ],
    "url": "docs/generated/shipit#examples",
    "content": "\nauto shipit\nauto shipit\n"
  },
  {
    "path": [
      "Publishing",
      "shipit",
      "Configurable Options"
    ],
    "url": "docs/generated/shipit#configurable-options",
    "content": "\nYou can configure some of the options for the shipit command in the .autorc.\nprereleasemessageno-changelogonly-graduate-with-release-label\nExample .autorc:\n{\n  \"shipit\": {\n    \"prerelease\": true,\n    \"message\": \"string\",\n    \"noChangelog\": true,\n    \"onlyGraduateWithReleaseLabel\": true\n  }\n}\n{\n  \"shipit\": {\n    \"prerelease\": true,\n    \"message\": \"string\",\n    \"noChangelog\": true,\n    \"onlyGraduateWithReleaseLabel\": true\n  }\n}\n"
  },
  {
    "path": [
      "Publishing",
      "shipit",
      "Release Pipeline"
    ],
    "url": "docs/generated/shipit#release-pipeline",
    "content": "\nBelow is the basics steps auto takes when releasing your code through the shipit command.\n\n\n\nYou can customize how this pipeline operates with various flags.\nThe following shows how those flags can effect the workflow.\n\n\n"
  },
  {
    "path": [
      "Publishing",
      "shipit",
      "Managing Old Major Versions"
    ],
    "url": "docs/generated/shipit#managing-old-major-versions",
    "content": "\nThis command also has the ability to help you manage old major versions too!\nThis feature is off by default, to enable set versionBranches to true in your .autorc.\nWith this feature enabled auto shipit will:\nCreate a version branch when a major happens (prefixed with version-)When ran from a versionBranch make a release to that version\nNow that you have a branch for an old major release, it is super easy to release patches to it!\nPeople can make PRs to the the version- branch and once merged create a new release of that version."
  },
  {
    "path": [
      "Publishing",
      "shipit",
      "Managing Old Major Versions",
      "Customize Branch Prefix"
    ],
    "url": "docs/generated/shipit#customize-branch-prefix",
    "content": "\nYou can customize what the branch names will be by setting versionBranches to a string.\n{\n  \"versionBranches\": \"Major-\"\n}\n{\n  \"versionBranches\": \"Major-\"\n}\n"
  },
  {
    "path": [
      "Publishing",
      "shipit",
      "Prereleases"
    ],
    "url": "docs/generated/shipit#prereleases",
    "content": "\nIf you are interested in pre-releases (ex: alpha, beta, next) auto has the ability to publish pre-releases in various ways.\nRead more about preparing you project for pre-releases here."
  },
  {
    "path": [
      "Publishing",
      "shipit",
      "Prereleases",
      "Strategies"
    ],
    "url": "docs/generated/shipit#strategies",
    "content": ""
  },
  {
    "path": [
      "Publishing",
      "shipit",
      "Prereleases",
      "Strategies",
      "\"next\" Branch (default)"
    ],
    "url": "docs/generated/shipit#next-branch-default",
    "content": "\nThe suggested way to create pre-releases is by managing 2 branches for your repo: baseBranch and next.\nbaseBranch contains the latest stable version of the code, and next contains future updates.\nYou can change what branches auto treats as pre-release branches in your .autorc.\n\n\n\nTo update the latest stable version simply merge your pre-release branch into your baseBranch."
  },
  {
    "path": [
      "Publishing",
      "shipit",
      "Prereleases",
      "Strategies",
      "Without \"next\" Branch (--only-graduate-with-release-label)"
    ],
    "url": "docs/generated/shipit#without-next-branch---only-graduate-with-release-label",
    "content": "\nIf you use the --only-graduate-with-release-label flag, you do not have to manage 2 branches.\nInstead you only have a baseBranch and do all work and pull requests there.\nauto will only publish pre-releases when PRs are merged.\nTo update the latest stable version add the released label to the PR.\nWhile this setup may be simpler, it restricts you from updating latest while development is happening for the pre-release.\nWith 2 branches you can easily merge update to the latest release, with 1 this is not possible."
  },
  {
    "path": [
      "Publishing",
      "shipit",
      "Prereleases",
      "Strategies",
      "Multiple \"next\" Branches"
    ],
    "url": "docs/generated/shipit#multiple-next-branches",
    "content": "\nSometimes you might want to have more rigorous release lines.\nThis can help test out bugs on a smaller set of users.\nOne setup you could use to accomplish this is by creating 3 prereleaseBranches\n{\n  \"prereleaseBranches\": [\"alpha\", \"beta\", \"rc\"]\n}\n{\n  \"prereleaseBranches\": [\"alpha\", \"beta\", \"rc\"]\n}\n\nYou could then set you default to alpha and auto would publish updates merged to that branch under the alpha release tag.\nWhen you are ready for the update to get used by more users just merge alpha into beta.\nThis will publish a beta release to the matching release tag.\nRepeat this same process when graduating to rc or latest."
  },
  {
    "path": [
      "Publishing",
      "shipit",
      "Prereleases",
      "Strategies",
      "Feature Pre-releases"
    ],
    "url": "docs/generated/shipit#feature-pre-releases",
    "content": "\nSometimes you are working on a large feature that requires a lot of work.\nInstead of making a giant PR with a bunch of updates, you can create a prereleaseBranch to track the work.\n{\n  \"prereleaseBranches\": [\"next\", \"my-cool-feature\"]\n}\n{\n  \"prereleaseBranches\": [\"next\", \"my-cool-feature\"]\n}\n\nNow instead of just getting a canary version when merging into the my-cool-feature branch, a prerelease version is published under the my-cool-feature release tag!\nThis enables other to consume just this line of work and enables your work to be more flexible."
  },
  {
    "path": [
      "Functionality Plugins",
      "Slack Plugin"
    ],
    "url": "docs/generated/slack",
    "content": "\nPost your release notes to a slack channel.\n\n\n"
  },
  {
    "path": [
      "Functionality Plugins",
      "Slack Plugin",
      "Installation"
    ],
    "url": "docs/generated/slack#installation",
    "content": "\nThis plugin is not included with the auto CLI installed via NPM. To install:\nnpm i --save-dev @auto-it/slack\n# or\nyarn add -D @auto-it/slack\nnpm i --save-dev @auto-it/slack\n# or\nyarn add -D @auto-it/slack\n"
  },
  {
    "path": [
      "Functionality Plugins",
      "Slack Plugin",
      "Usage"
    ],
    "url": "docs/generated/slack#usage",
    "content": ""
  },
  {
    "path": [
      "Functionality Plugins",
      "Slack Plugin",
      "Usage",
      "Incoming Webhook + Token"
    ],
    "url": "docs/generated/slack#incoming-webhook--token",
    "content": "\nThis is the easier option to set up, but it has less features than app auth.\nThere are a few options on how to call/construct the webhook URL:\n{\n  \"plugins\": [\n    // Webhook URL Only:\n    // Store the hook URL in `SLACK_WEBHOOK_URL` so you don't commit it\n    \"slack\",\n    // Incoming  Webhook URL + Token:\n    // Set generic app hook URL in `.autorc` as `url` and set the\n    // `SLACK_TOKEN` variable available on your environment.\n    //\n    // This token will be added to the URL as a query string parameter.\n    [\"slack\", { \"url\": \"https://url-to-your-slack-hook.com\" }]\n  ]\n}\n{\n  \"plugins\": [\n    // Webhook URL Only:\n    // Store the hook URL in `SLACK_WEBHOOK_URL` so you don't commit it\n    \"slack\",\n    // Incoming  Webhook URL + Token:\n    // Set generic app hook URL in `.autorc` as `url` and set the\n    // `SLACK_TOKEN` variable available on your environment.\n    //\n    // This token will be added to the URL as a query string parameter.\n    [\"slack\", { \"url\": \"https://url-to-your-slack-hook.com\" }]\n  ]\n}\n\nRead more about Slack incoming webhooks here."
  },
  {
    "path": [
      "Functionality Plugins",
      "Slack Plugin",
      "Usage",
      "App Auth Token"
    ],
    "url": "docs/generated/slack#app-auth-token",
    "content": "\nAn incoming webhook can work for most situations but to enable a better integration we need an app auth token. This enables us to:\nUpload text snippets for code blocks in release notesPost to multiple channels\nFor this to work you need to create an app with the following permissions:\nfiles:writechat:write\nSet the auth option to app and the SLACK_TOKEN will be used to authenticate as an app.\n{\n  \"plugins\": [\n    [\n      \"slack\",\n      {\n        \"auth\": \"app\",\n        \"channels\": [\"app-update-channel\", \"private-team-channel\"]\n      }\n    ]\n  ]\n}\n{\n  \"plugins\": [\n    [\n      \"slack\",\n      {\n        \"auth\": \"app\",\n        \"channels\": [\"app-update-channel\", \"private-team-channel\"]\n      }\n    ]\n  ]\n}\n\nRead about creating an installing apps."
  },
  {
    "path": [
      "Functionality Plugins",
      "Slack Plugin",
      "Options"
    ],
    "url": "docs/generated/slack#options",
    "content": ""
  },
  {
    "path": [
      "Functionality Plugins",
      "Slack Plugin",
      "Options",
      "atTarget"
    ],
    "url": "docs/generated/slack#attarget",
    "content": "\nWho to tag when posting a message.\nDefaults to channel.\nSome less chatty options are:\n{\n  \"plugins\": [\n    [\n      \"slack\",\n      {\n        \"url\": \"https://url-to-your-slack-hook.com\",\n        // Only tag people online\n        \"atTarget\": \"here\"\n      }\n    ],\n    [\n      \"slack\",\n      {\n        \"url\": \"https://url-to-your-slack-hook.com\",\n        // Tag a custom group, like the channel admin\n        \"atTarget\": \"channel-admin\"\n      }\n    ]\n  ]\n}\n{\n  \"plugins\": [\n    [\n      \"slack\",\n      {\n        \"url\": \"https://url-to-your-slack-hook.com\",\n        // Only tag people online\n        \"atTarget\": \"here\"\n      }\n    ],\n    [\n      \"slack\",\n      {\n        \"url\": \"https://url-to-your-slack-hook.com\",\n        // Tag a custom group, like the channel admin\n        \"atTarget\": \"channel-admin\"\n      }\n    ]\n  ]\n}\n"
  },
  {
    "path": [
      "Functionality Plugins",
      "Slack Plugin",
      "Options",
      "publishPreRelease"
    ],
    "url": "docs/generated/slack#publishprerelease",
    "content": "\nIf you are using a prerelease branch like next, Slack will not post a message by default.\nThis is done to avoid spamming your consumers every time you make a preview release.\nHowever, if you would like to configure it such that Slack does post on prerelease, you can add the publishPreRelease to your .autorc like so:\n{\n  \"plugins\": [\n    [\n      \"slack\",\n      { \"url\": \"https://url-to-your-slack-hook.com\", \"publishPreRelease\": true }\n    ]\n  ]\n}\n{\n  \"plugins\": [\n    [\n      \"slack\",\n      { \"url\": \"https://url-to-your-slack-hook.com\", \"publishPreRelease\": true }\n    ]\n  ]\n}\n"
  },
  {
    "path": [
      "Functionality Plugins",
      "Slack Plugin",
      "Options",
      "title"
    ],
    "url": "docs/generated/slack#title",
    "content": "\nAdditional Title to add at the start of the slack message.\n{\n  \"plugins\": [\n    [\n      \"slack\",\n      {\n        \"url\": \"https://url-to-your-slack-hook.com\",\n        \"title\": \"My Cool Project\"\n      }\n    ]\n  ]\n}\n{\n  \"plugins\": [\n    [\n      \"slack\",\n      {\n        \"url\": \"https://url-to-your-slack-hook.com\",\n        \"title\": \"My Cool Project\"\n      }\n    ]\n  ]\n}\n"
  },
  {
    "path": [
      "Functionality Plugins",
      "Slack Plugin",
      "Options",
      "username"
    ],
    "url": "docs/generated/slack#username",
    "content": "\nUsername to post the message as.\n{\n  \"plugins\": [\n    [\n      \"slack\",\n      {\n        \"url\": \"https://url-to-your-slack-hook.com\",\n        \"username\": \"My Project\"\n      }\n    ]\n  ]\n}\n{\n  \"plugins\": [\n    [\n      \"slack\",\n      {\n        \"url\": \"https://url-to-your-slack-hook.com\",\n        \"username\": \"My Project\"\n      }\n    ]\n  ]\n}\n"
  },
  {
    "path": [
      "Functionality Plugins",
      "Slack Plugin",
      "Options",
      "iconUrl"
    ],
    "url": "docs/generated/slack#iconurl",
    "content": "\nImage url to use as the message's avatar.\n{\n  \"plugins\": [\n    [\n      \"slack\",\n      {\n        \"url\": \"https://url-to-your-slack-hook.com\",\n        \"iconUrl\": \"http://lorempixel.com/48/48\"\n      }\n    ]\n  ]\n}\n{\n  \"plugins\": [\n    [\n      \"slack\",\n      {\n        \"url\": \"https://url-to-your-slack-hook.com\",\n        \"iconUrl\": \"http://lorempixel.com/48/48\"\n      }\n    ]\n  ]\n}\n\nNOTE: If both iconUrl and iconEmoji are specified only iconUrl will be respected"
  },
  {
    "path": [
      "Functionality Plugins",
      "Slack Plugin",
      "Options",
      "iconEmoji"
    ],
    "url": "docs/generated/slack#iconemoji",
    "content": "\nEmoji code to use as the message's avatar.\n{\n  \"plugins\": [\n    [\n      \"slack\",\n      {\n        \"url\": \"https://url-to-your-slack-hook.com\",\n        \"iconEmoji\": \":chart_with_upwards_trend:\"\n      }\n    ]\n  ]\n}\n{\n  \"plugins\": [\n    [\n      \"slack\",\n      {\n        \"url\": \"https://url-to-your-slack-hook.com\",\n        \"iconEmoji\": \":chart_with_upwards_trend:\"\n      }\n    ]\n  ]\n}\n"
  },
  {
    "path": [
      "Functionality Plugins",
      "Slack Plugin",
      "Options",
      "channels (App Auth Only)"
    ],
    "url": "docs/generated/slack#channels-app-auth-only",
    "content": "\nChannel, private group, or IM channel to send message to.\nCan be an encoded ID, or a name.\n{\n  \"plugins\": [\n    [\n      \"slack\",\n      {\n        \"auth\": \"app\",\n        \"channels\": [\"app-update-channel\", \"private-team-channel\"]\n      }\n    ]\n  ]\n}\n{\n  \"plugins\": [\n    [\n      \"slack\",\n      {\n        \"auth\": \"app\",\n        \"channels\": [\"app-update-channel\", \"private-team-channel\"]\n      }\n    ]\n  ]\n}\n\nRead here for more details."
  },
  {
    "path": [
      "Functionality Plugins",
      "Slack Plugin",
      "Creating a Slack App"
    ],
    "url": "docs/generated/slack#creating-a-slack-app",
    "content": "\nThere are a lot of steps to creating a Slack app and installing it.\nLet's go over what you'll need to do to get set up with app auth.\nCreate the appFrom your app's Basic Information page go to Permissions => Bot Token Scopes and add chat:write and file:write (Optionally add chat:write.customize to use the username and icon options)Copy the Bot User OAuth Access Token into your .env file and store it as SLACK_TOKENInstall the app in the channels you want it to post to via the Slack UI"
  },
  {
    "path": [
      "Functionality Plugins",
      "Slack Plugin",
      "Creating a Slack App",
      "Customize the App"
    ],
    "url": "docs/generated/slack#customize-the-app",
    "content": "\nTo make you app shine in Slack head to Basic Information and scroll down to Display Information.\nHer you should set a description for the app and give it an icon and color.\nThis could be your code's logo or one of our logos."
  },
  {
    "path": [
      "Functionality Plugins",
      "Twitter Plugin"
    ],
    "url": "docs/generated/twitter",
    "content": "\nPost tweets after a release is made."
  },
  {
    "path": [
      "Functionality Plugins",
      "Twitter Plugin",
      "Prerequisites"
    ],
    "url": "docs/generated/twitter#prerequisites",
    "content": "\nTo post tweets to twitter you need the following secrets set in your environment:\nTWITTER_ACCESS_TOKENTWITTER_ACCESS_TOKEN_SECRETTWITTER_CONSUMER_KEYTWITTER_CONSUMER_KEY_SECRET"
  },
  {
    "path": [
      "Functionality Plugins",
      "Twitter Plugin",
      "Installation"
    ],
    "url": "docs/generated/twitter#installation",
    "content": "\nThis plugin is not included with the auto CLI installed via NPM. To install:\nnpm i --save-dev @auto-it/twitter\n# or\nyarn add -D @auto-it/twitter\nnpm i --save-dev @auto-it/twitter\n# or\nyarn add -D @auto-it/twitter\n"
  },
  {
    "path": [
      "Functionality Plugins",
      "Twitter Plugin",
      "Usage"
    ],
    "url": "docs/generated/twitter#usage",
    "content": "\nSimply supply the names of the account to filter\n{\n  \"plugins\": [\n    [\n      \"twitter\",\n      {\n        /* options */\n      }\n    ]\n  ]\n}\n{\n  \"plugins\": [\n    [\n      \"twitter\",\n      {\n        /* options */\n      }\n    ]\n  ]\n}\n"
  },
  {
    "path": [
      "Functionality Plugins",
      "Twitter Plugin",
      "Options"
    ],
    "url": "docs/generated/twitter#options",
    "content": ""
  },
  {
    "path": [
      "Functionality Plugins",
      "Twitter Plugin",
      "Options",
      "Message"
    ],
    "url": "docs/generated/twitter#message",
    "content": "\nYou can configure the message posted to twitter. The message option should use the following special tokens to create a tweet.\n%release - The version bump (major, minor, patch)%package - The name of the package%notes - Your release notes truncated to fit in the tweet%link - A link to your the release on GitHub%version - The latest version number\nDefault:\nA new %release version of %package was released!\n\n%notes\n\n%link\nA new %release version of %package was released!\n\n%notes\n\n%link\n\n{\n  \"plugins\": [\n    [\"twitter\", { \"message\": \"v%version of %package was released!\\n\\n%link\" }]\n  ]\n}\n{\n  \"plugins\": [\n    [\"twitter\", { \"message\": \"v%version of %package was released!\\n\\n%link\" }]\n  ]\n}\n"
  },
  {
    "path": [
      "Functionality Plugins",
      "Twitter Plugin",
      "Options",
      "Threshold"
    ],
    "url": "docs/generated/twitter#threshold",
    "content": "\nBy default the twitter plugin will only tweet if the version difference between the latest and the last release is greater than a minor.\n{\n  \"plugins\": [[\"twitter\", { \"threshold\": \"major\" }]]\n}\n{\n  \"plugins\": [[\"twitter\", { \"threshold\": \"major\" }]]\n}\n"
  },
  {
    "path": [
      "Functionality Plugins",
      "Upload Assets Plugin"
    ],
    "url": "docs/generated/upload-assets",
    "content": "\nUpload assets to the release.\nGood for executables and extra downloadable files.\nAlso supports canaries!\nNOTE: For canaries to work this plugin must be listed before any other publishing plugin."
  },
  {
    "path": [
      "Functionality Plugins",
      "Upload Assets Plugin",
      "Installation"
    ],
    "url": "docs/generated/upload-assets#installation",
    "content": "\nThis plugin is not included with the auto CLI installed via NPM. To install:\nnpm i --save-dev @auto-it/upload-assets\n# or\nyarn add -D @auto-it/upload-assets\nnpm i --save-dev @auto-it/upload-assets\n# or\nyarn add -D @auto-it/upload-assets\n"
  },
  {
    "path": [
      "Functionality Plugins",
      "Upload Assets Plugin",
      "Usage"
    ],
    "url": "docs/generated/upload-assets#usage",
    "content": "\nSimply supply the paths to the assets to add to the release.\n{\n  \"plugins\": [\n    [\"upload-assets\", { \"assets\": [\"./path/to/file\"] }],\n    // or\n    [\"upload-assets\", [\"./path/to/file\"]],\n    // or use globs to upload multiple things\n    [\"upload-assets\", [\"./path/**/to/*.file\"]]\n  ]\n}\n{\n  \"plugins\": [\n    [\"upload-assets\", { \"assets\": [\"./path/to/file\"] }],\n    // or\n    [\"upload-assets\", [\"./path/to/file\"]],\n    // or use globs to upload multiple things\n    [\"upload-assets\", [\"./path/**/to/*.file\"]]\n  ]\n}\n"
  },
  {
    "path": [
      "Functionality Plugins",
      "Upload Assets Plugin",
      "Options"
    ],
    "url": "docs/generated/upload-assets#options",
    "content": ""
  },
  {
    "path": [
      "Functionality Plugins",
      "Upload Assets Plugin",
      "Options",
      "maxCanaryAssets"
    ],
    "url": "docs/generated/upload-assets#maxcanaryassets",
    "content": "\nMax number of assets to keep in the canary release.\n{\n  \"plugins\": [\n    [\n      \"upload-assets\",\n      {\n        \"assets\": [\"./path/to/file\"],\n        \"maxAssets\": 100\n      }\n    ]\n  ]\n}\n{\n  \"plugins\": [\n    [\n      \"upload-assets\",\n      {\n        \"assets\": [\"./path/to/file\"],\n        \"maxAssets\": 100\n      }\n    ]\n  ]\n}\n"
  },
  {
    "path": [
      "Publishing",
      "version"
    ],
    "url": "docs/generated/version",
    "content": "\nCalculate a semantic version bump for the given changes.\nRequires all PRs to have labels for the change type.\nIf a PR does not have a label associated with it, it will default to patch or whatever you configure the default label to.\nNOTE: This does not change the version of your project or anything in your repo. It just returns patch, minor, or major."
  },
  {
    "path": [
      "Publishing",
      "version",
      "Options"
    ],
    "url": "docs/generated/version#options",
    "content": "\nFlagTypeDescription--only-publish-with-release-labelBooleanOnly bump version if 'release' label is on pull request--fromStringGit revision (tag, commit sha, ...) to calculate version bump from. Defaults to latest github release"
  },
  {
    "path": [
      "Publishing",
      "version",
      "Examples"
    ],
    "url": "docs/generated/version#examples",
    "content": "\nGet the new version using the last release to head\nauto version\nauto version\n\nUseful in conjunction with npm version to auto-version releases."
  },
  {
    "path": [
      "Publishing",
      "version",
      "Configure Versioning Labels"
    ],
    "url": "docs/generated/version#configure-versioning-labels",
    "content": "\nYou can customize the versioning labels in the .autorc. To see configuration go here."
  },
  {
    "path": [
      "Package Manager Plugins",
      "Vscode Plugin"
    ],
    "url": "docs/generated/vscode",
    "content": "\nPublish a vscode extension."
  },
  {
    "path": [
      "Package Manager Plugins",
      "Vscode Plugin",
      "Installation"
    ],
    "url": "docs/generated/vscode#installation",
    "content": "\nThis plugin is not included with the auto CLI installed via NPM. To install:\nnpm i --save-dev @auto-it/vscode\n# or\nyarn add -D @auto-it/vscode\nnpm i --save-dev @auto-it/vscode\n# or\nyarn add -D @auto-it/vscode\n"
  },
  {
    "path": [
      "Package Manager Plugins",
      "Vscode Plugin",
      "Usage"
    ],
    "url": "docs/generated/vscode#usage",
    "content": "\n{\n  \"plugins\": [\n    \"vscode\"\n    // other plugins\n  ]\n}\n{\n  \"plugins\": [\n    \"vscode\"\n    // other plugins\n  ]\n}\n"
  },
  {
    "path": [
      "Package Manager Plugins",
      "Vscode Plugin",
      "Setup"
    ],
    "url": "docs/generated/vscode#setup",
    "content": "\nCreate an organization for your extensionCreate a personal access token and store the token in your .env file as VSCE_TOKEN and add the same variable to your CICreate a publisher for your extension and set the publisher in your package.json\nThat's it!\nLearn more about creating a great looking extension."
  },
  {
    "path": [
      "Package Manager Plugins",
      "Vscode Plugin",
      "Options"
    ],
    "url": "docs/generated/vscode#options",
    "content": ""
  },
  {
    "path": [
      "Package Manager Plugins",
      "Vscode Plugin",
      "Options",
      "baseContentUrl"
    ],
    "url": "docs/generated/vscode#basecontenturl",
    "content": "\nPrepend all relative links in README.md with this url.\n{\n  \"plugins\": [\n    [\n      \"vscode\",\n      { \"baseContentUrl\": \"https://github.com/my-username/my-repo/tree/main\" }\n    ]\n    // other plugins\n  ]\n}\n{\n  \"plugins\": [\n    [\n      \"vscode\",\n      { \"baseContentUrl\": \"https://github.com/my-username/my-repo/tree/main\" }\n    ]\n    // other plugins\n  ]\n}\n"
  },
  {
    "path": [
      "Package Manager Plugins",
      "Vscode Plugin",
      "Options",
      "baseImagesUrl"
    ],
    "url": "docs/generated/vscode#baseimagesurl",
    "content": "\nPrepend all relative image links in README.md with this url.\n{\n  \"plugins\": [\n    // other plugins\n    [\n      \"vscode\",\n      {\n        \"baseContentUrl\": \"https://raw.githubusercontent.com/my-username/my-repo/main/\"\n      }\n    ]\n  ]\n}\n{\n  \"plugins\": [\n    // other plugins\n    [\n      \"vscode\",\n      {\n        \"baseContentUrl\": \"https://raw.githubusercontent.com/my-username/my-repo/main/\"\n      }\n    ]\n  ]\n}\n"
  },
  {
    "path": [
      "Plugin Authoring",
      "Changelog Hooks"
    ],
    "url": "docs/plugins/changelog-hooks",
    "content": "\nOne of the main outputs from auto is the changelogs it produces.\nThe changelog is created from a set of commits that has been parsed using the log parser.\nThe hooks it provides allow you to customize everything about how the changelog renders.\nonCreateChangelogaddToBodyrenderChangelogLinesortChangelogLinesrenderChangelogTitlerenderChangelogAuthorrenderChangelogAuthorLinecreateChangelogTitleomitReleaseNotes"
  },
  {
    "path": [
      "Plugin Authoring",
      "Changelog Hooks",
      "onCreateChangelog"
    ],
    "url": "docs/plugins/changelog-hooks#oncreatechangelog",
    "content": "\nThis is where you hook into the changelog's hooks.\nSee examples below.\nauto.hooks.onCreateChangelog.tapPromise(\"Giphy\", (changelog, { bump }) => {});\nauto.hooks.onCreateChangelog.tapPromise(\"Giphy\", (changelog, { bump }) => {});\n"
  },
  {
    "path": [
      "Plugin Authoring",
      "Changelog Hooks",
      "addToBody"
    ],
    "url": "docs/plugins/changelog-hooks#addtobody",
    "content": "\nAdd extra content to your changelogs.\nThis hook provide all the current \"extra\" notes and all of the commits for the changelog.\nYou must return the notes array.\nThe following adds a random GIF from giphy to each new changelog.\nauto.hooks.onCreateChangelog.tapPromise('Giphy', changelog =>\n  changelog.hooks.addToBody.tapPromise(\n    'Giphy',\n    async (notes, commits) => {\n      const response = await fetch(`https://api.giphy.com/v1/gifs/random?api_key=${process.env.GIPHY_KEY}`);\n      const json = await response.json();\n      const { data: gif } = json;\n\n      return [...notes, `![${gif.title}](${gif.url})\\n`]\n    }\n  );\n);\nauto.hooks.onCreateChangelog.tapPromise('Giphy', changelog =>\n  changelog.hooks.addToBody.tapPromise(\n    'Giphy',\n    async (notes, commits) => {\n      const response = await fetch(`https://api.giphy.com/v1/gifs/random?api_key=${process.env.GIPHY_KEY}`);\n      const json = await response.json();\n      const { data: gif } = json;\n\n      return [...notes, `![${gif.title}](${gif.url})\\n`]\n    }\n  );\n);\n\nOther examples:\nfirst-time-contributor - Add new contributor announcements to changelogs"
  },
  {
    "path": [
      "Plugin Authoring",
      "Changelog Hooks",
      "renderChangelogLine"
    ],
    "url": "docs/plugins/changelog-hooks#renderchangelogline",
    "content": "\nChange how the changelog renders lines.\nThis hook provides the commit and the current state of the line render.\nYou must return the commit and the line string state as a tuple ([commit, line]).\nThe following plugin would change all the bullet points in the changelog to star emojis.\nauto.hooks.onCreateChangelog.tapPromise('Stars', changelog =>\n  changelog.hooks.renderChangelogLine.tapPromise(\n    'Stars',\n    async (line, commit) => `${line.replace('-', ':star:')}\\n`\n  );\n);\nauto.hooks.onCreateChangelog.tapPromise('Stars', changelog =>\n  changelog.hooks.renderChangelogLine.tapPromise(\n    'Stars',\n    async (line, commit) => `${line.replace('-', ':star:')}\\n`\n  );\n);\n"
  },
  {
    "path": [
      "Plugin Authoring",
      "Changelog Hooks",
      "sortChangelogLines"
    ],
    "url": "docs/plugins/changelog-hooks#sortchangeloglines",
    "content": "\nChange how the changelog lines are sorted\nYou must return the lines from this hook.\nauto.hooks.onCreateChangelog.tapPromise('Stars', changelog =>\n  changelog.hooks.sortChangelogLines.tapPromise(\n    'Stars',\n    async (lines) => {\n      // sorting logic\n    }\n  );\n);\nauto.hooks.onCreateChangelog.tapPromise('Stars', changelog =>\n  changelog.hooks.sortChangelogLines.tapPromise(\n    'Stars',\n    async (lines) => {\n      // sorting logic\n    }\n  );\n);\n\nOther examples:\njira - Render JIRA story information in the changelognpm - Render monorepo information in the changelog"
  },
  {
    "path": [
      "Plugin Authoring",
      "Changelog Hooks",
      "renderChangelogTitle"
    ],
    "url": "docs/plugins/changelog-hooks#renderchangelogtitle",
    "content": "\nChange how the changelog renders titles.\nThe hook provides the current label for the section and all the configured changelog titles.\nauto.hooks.onCreateChangelog.tapPromise('Stars', changelog =>\n  changelog.hooks.renderChangelogTitle.tap(\n    'My Titles',\n    (label, changelogTitles) => `:heart: ${changelogTitles[label]} :heart:`\n  );\n);\nauto.hooks.onCreateChangelog.tapPromise('Stars', changelog =>\n  changelog.hooks.renderChangelogTitle.tap(\n    'My Titles',\n    (label, changelogTitles) => `:heart: ${changelogTitles[label]} :heart:`\n  );\n);\n"
  },
  {
    "path": [
      "Plugin Authoring",
      "Changelog Hooks",
      "renderChangelogAuthor"
    ],
    "url": "docs/plugins/changelog-hooks#renderchangelogauthor",
    "content": "\nChange how the changelog renders author accounts (ex: linking to GitHub accounts).\nThis is both the author on each commit note and the user in the author section (the part between parentheses).\nThis is generally a link to some profile.\nauto.hooks.onCreateChangelog.tapPromise('Stars', changelog =>\n  changelog.hooks.renderChangelogAuthor.tap(\n    'test',\n    (author, commit) => `:heart: ${author.name}/${commit.authorEmail} :heart:`\n  );\n);\nauto.hooks.onCreateChangelog.tapPromise('Stars', changelog =>\n  changelog.hooks.renderChangelogAuthor.tap(\n    'test',\n    (author, commit) => `:heart: ${author.name}/${commit.authorEmail} :heart:`\n  );\n);\n"
  },
  {
    "path": [
      "Plugin Authoring",
      "Changelog Hooks",
      "renderChangelogAuthorLine"
    ],
    "url": "docs/plugins/changelog-hooks#renderchangelogauthorline",
    "content": "\nChange how the changelog renders each line in the authors section.\nThe hook provides the author object and the user created with renderChangelogAuthor.\nHere is where you might display extra info about the author, such as their full name.\nauto.hooks.onCreateChangelog.tapPromise('Stars', changelog =>\n  changelog.hooks.renderChangelogAuthorLine.tap(\n    'test',\n    (author, user) => `:shipit: ${author.name} (${user})\\n`\n  );\n);\nauto.hooks.onCreateChangelog.tapPromise('Stars', changelog =>\n  changelog.hooks.renderChangelogAuthorLine.tap(\n    'test',\n    (author, user) => `:shipit: ${author.name} (${user})\\n`\n  );\n);\n"
  },
  {
    "path": [
      "Plugin Authoring",
      "Changelog Hooks",
      "createChangelogTitle"
    ],
    "url": "docs/plugins/changelog-hooks#createchangelogtitle",
    "content": "\nControl the titles in the CHANGELOG.md\n// Render only the date in the title\nauto.hooks.onCreateRelease.tap(this.name, (release) => {\n  release.hooks.createChangelogTitle.tap(\n    `${this.name} - lerna independent`,\n    () => \"\"\n  );\n});\n// Render only the date in the title\nauto.hooks.onCreateRelease.tap(this.name, (release) => {\n  release.hooks.createChangelogTitle.tap(\n    `${this.name} - lerna independent`,\n    () => \"\"\n  );\n});\n\nOther examples:\nIn Core: Powers the auto changelog --title flagnpm - Gives independent monorepo a different title"
  },
  {
    "path": [
      "Plugin Authoring",
      "Changelog Hooks",
      "omitReleaseNotes"
    ],
    "url": "docs/plugins/changelog-hooks#omitreleasenotes",
    "content": "\nControl what commits get into the additional release notes section.\nauto.hooks.onCreateChangelog.tap(this.name, (changelog) => {\n  changelog.hooks.omitReleaseNotes.tap(this.name, (commit) =>\n    commit.subject.includes(\"WIP\")\n  );\n});\nauto.hooks.onCreateChangelog.tap(this.name, (changelog) => {\n  changelog.hooks.omitReleaseNotes.tap(this.name, (commit) =>\n    commit.subject.includes(\"WIP\")\n  );\n});\n\nOther examples:\nIn Core: Ignore release notes in PRs from common bot accountsomit-release-notes - Omit release notes from authors, labels, and more"
  },
  {
    "path": [
      "Plugin Authoring",
      "Configuration Hooks"
    ],
    "url": "docs/plugins/configuration-hooks",
    "content": "\nAll of the following hooks in some way deal with detecting, modifying and validating auto's configuration.\nbeforeRunmodifyConfiggetAuthorgetPreviousVersiongetRepositoryvalidateConfig"
  },
  {
    "path": [
      "Plugin Authoring",
      "Configuration Hooks",
      "beforeRun"
    ],
    "url": "docs/plugins/configuration-hooks#beforerun",
    "content": "\nHappens before any command is run.\nThis is a great place to check for platform specific secrets such as a npm token.\nauto.hooks.beforeRun.tapPromise(\"NPM\", async (config) => {\n  if (!process.env.NPM_TOKEN) {\n    auto.logger.log.warn(\"NPM Token is needed for the NPM plugin!\");\n  }\n});\nauto.hooks.beforeRun.tapPromise(\"NPM\", async (config) => {\n  if (!process.env.NPM_TOKEN) {\n    auto.logger.log.warn(\"NPM Token is needed for the NPM plugin!\");\n  }\n});\n"
  },
  {
    "path": [
      "Plugin Authoring",
      "Configuration Hooks",
      "modifyConfig"
    ],
    "url": "docs/plugins/configuration-hooks#modifyconfig",
    "content": "\nModify what is in the config.\nYou must return the config in this hook.\nIf you plugins requires some option to be set this is the place to do it.\nauto.hooks.modifyConfig.tap(\"test\", (config) => {\n  config.labels.released = {\n    name: \"released\",\n    description: \"This issue/pull request has been released\",\n  };\n\n  return config;\n});\nauto.hooks.modifyConfig.tap(\"test\", (config) => {\n  config.labels.released = {\n    name: \"released\",\n    description: \"This issue/pull request has been released\",\n  };\n\n  return config;\n});\n\nOther examples:\ncocoapods - Sets noVersionPrefix to true for independent monoreposnpm - Sets noVersionPrefix to true for independent monoreposrelease - Adds released label"
  },
  {
    "path": [
      "Plugin Authoring",
      "Configuration Hooks",
      "getAuthor"
    ],
    "url": "docs/plugins/configuration-hooks#getauthor",
    "content": "\nGet git author to commit with.\nTypically from a package distribution description file.\nauto.hooks.getAuthor.tapPromise(\"NPM\", async () => {\n  const { author } = JSON.parse(await readFile(\"package.json\", \"utf-8\"));\n\n  if (author) {\n    return author;\n  }\n});\nauto.hooks.getAuthor.tapPromise(\"NPM\", async () => {\n  const { author } = JSON.parse(await readFile(\"package.json\", \"utf-8\"));\n\n  if (author) {\n    return author;\n  }\n});\n"
  },
  {
    "path": [
      "Plugin Authoring",
      "Configuration Hooks",
      "getPreviousVersion"
    ],
    "url": "docs/plugins/configuration-hooks#getpreviousversion",
    "content": "\nGet the previous version.\nTypically from a package distribution description file.\nThis hooks is required for plugin that facilitate publishing.\nauto.hooks.getPreviousVersion.tapPromise(\"NPM\", async () => {\n  const { version } = JSON.parse(await readFile(\"package.json\", \"utf-8\"));\n\n  if (version) {\n    return auto.prefixRelease(\n      JSON.parse(await readFile(\"package.json\", \"utf-8\")).version\n    );\n  }\n});\nauto.hooks.getPreviousVersion.tapPromise(\"NPM\", async () => {\n  const { version } = JSON.parse(await readFile(\"package.json\", \"utf-8\"));\n\n  if (version) {\n    return auto.prefixRelease(\n      JSON.parse(await readFile(\"package.json\", \"utf-8\")).version\n    );\n  }\n});\n"
  },
  {
    "path": [
      "Plugin Authoring",
      "Configuration Hooks",
      "getRepository"
    ],
    "url": "docs/plugins/configuration-hooks#getrepository",
    "content": "\nGet owner and repository for the project to automate releases for.\nTypically from a package distribution description file.\nFalls back to global git config author.\nauto.hooks.getRepository.tapPromise('NPM', async () => {\n  const owner = // get the owner from package.json\n  const repo = // get the repo from package.json\n\n  return {\n    owner,\n    repo\n  }\n});\nauto.hooks.getRepository.tapPromise('NPM', async () => {\n  const owner = // get the owner from package.json\n  const repo = // get the repo from package.json\n\n  return {\n    owner,\n    repo\n  }\n});\n"
  },
  {
    "path": [
      "Plugin Authoring",
      "Configuration Hooks",
      "validateConfig"
    ],
    "url": "docs/plugins/configuration-hooks#validateconfig",
    "content": "\nValidate how your plugin is configured.\nMake sure to account for the different ways you plugin can be included in an .autorc.\nauto.hooks.validateConfig.tapPromise(\"test\", (name, options) => {\n  if (name === this.name || name === `auto-plugin-${this.name}`) {\n    return; // your validation error. Can either be strings for { path, expectedType, value }\n  }\n});\nauto.hooks.validateConfig.tapPromise(\"test\", (name, options) => {\n  if (name === this.name || name === `auto-plugin-${this.name}`) {\n    return; // your validation error. Can either be strings for { path, expectedType, value }\n  }\n});\n\nauto and it's plugins use io-ts to validate the options for a plugin.\nIf you're using typescript this is a great way to define the options for your plugin.\n// Types in TypeScript\ninterface Options {\n  level?: string;\n  user?: string;\n}\n\n// The equivalent io-ts code\nimport * as t from \"io-ts\";\n\nconst pluginOptions = t.partial({\n  level: t.string,\n  user: t.string,\n});\n\nexport type Options = t.TypeOf<typeof pluginOptions>;\n// Types in TypeScript\ninterface Options {\n  level?: string;\n  user?: string;\n}\n\n// The equivalent io-ts code\nimport * as t from \"io-ts\";\n\nconst pluginOptions = t.partial({\n  level: t.string,\n  user: t.string,\n});\n\nexport type Options = t.TypeOf<typeof pluginOptions>;\n\nSince your type information will now be available at runtime (in pluginOptions) you can use this to validate the configuration!\nTo do this auto exposes a helper function to validate you plugins with the io-ts types.\nimport { validatePluginConfiguration } from \"@auto-it/core\";\n\nauto.hooks.validateConfig.tapPromise(\"test\", (name, options) => {\n  if (name === this.name || name === `auto-plugin-${this.name}`) {\n    return validatePluginConfiguration(this.name, pluginOptions, options);\n  }\n});\nimport { validatePluginConfiguration } from \"@auto-it/core\";\n\nauto.hooks.validateConfig.tapPromise(\"test\", (name, options) => {\n  if (name === this.name || name === `auto-plugin-${this.name}`) {\n    return validatePluginConfiguration(this.name, pluginOptions, options);\n  }\n});\n"
  },
  {
    "path": [
      "Plugin Authoring",
      "Hook APIs"
    ],
    "url": "docs/plugins/hook-api-docs",
    "content": "\nPlugins work by \"hooking\" into various parts of auto to control or add to its behavior.\nThe categories of hooks available to plugins are:\nInit - Add functionality to auto initConfiguration - Detect, modify and validate auto's configurationLog Parser - Extend how auto analyzes commitsChangelog - Change how auto renders changelogsRelease Lifecycle - Called during various release commands, these facilitate publishing the package\nThe hooks that are called depends on the command is run.\nSome hooks are specific to a single command, such as the \"Init\" hooks, and others are called for every command.\nHere is a map of all the hooks and when they are called (open in new tab for more detail):\n\n\n"
  },
  {
    "path": [
      "Plugin Authoring",
      "Hook APIs",
      "Plugin Ideas"
    ],
    "url": "docs/plugins/hook-api-docs#plugin-ideas",
    "content": "\nHaving a plug-able release process means you can automate so many things.\nHere are a few ideas of what you could do.\nsize-changelog: Every time a latest release is made update a size-changelog.md with the bundle sizeUse the afterRelease hook to communicate changes to consumers (ex: twitter or slack)\nThe documentation for each hook also lists examples of how the hook is used in various parts of auto and its plugins."
  },
  {
    "path": [
      "Plugin Authoring",
      "Init APIs"
    ],
    "url": "docs/plugins/init-hooks",
    "content": "\nThe auto init command provides an easy way to create an .autorc without reading too many docs.\nIt exposes hooks to get the basic information auto needs to function (getRepo and getAuthor).\nIt also provides hooks the set up your plugin quicker (configurePlugin and createEnv).\nwriteRcFilegetRepogetAuthorconfigurePlugincreateEnv"
  },
  {
    "path": [
      "Plugin Authoring",
      "Init APIs",
      "writeRcFile"
    ],
    "url": "docs/plugins/init-hooks#writercfile",
    "content": "\nOverride where/how the rc file is written.\nclass MyPlugin implements IPlugin {\n  init(initializer: InteractiveInit) {\n    initializer.hooks.writeRcFile.tapPromise(\"Example\", async (rc) => {\n      // write the file somewhere other than .autorc\n      return filename;\n    });\n  }\n}\nclass MyPlugin implements IPlugin {\n  init(initializer: InteractiveInit) {\n    initializer.hooks.writeRcFile.tapPromise(\"Example\", async (rc) => {\n      // write the file somewhere other than .autorc\n      return filename;\n    });\n  }\n}\n\nOther examples:\nIn Core: Defaults to writing rc file to root of projectnpm - Writes RC file to package.json"
  },
  {
    "path": [
      "Plugin Authoring",
      "Init APIs",
      "getRepo"
    ],
    "url": "docs/plugins/init-hooks#getrepo",
    "content": "\nGet or verify the repo information.\nExamples:\nnpm - Gets repo info from package.json"
  },
  {
    "path": [
      "Plugin Authoring",
      "Init APIs",
      "getAuthor"
    ],
    "url": "docs/plugins/init-hooks#getauthor",
    "content": "\nGet or verify the author information.\nExamples:\nnpm - Gets author info from package.json"
  },
  {
    "path": [
      "Plugin Authoring",
      "Init APIs",
      "configurePlugin"
    ],
    "url": "docs/plugins/init-hooks#configureplugin",
    "content": "\nRun extra configuration for a plugin. Here is where to display prompts to the user.\nclass MyPlugin implements IPlugin {\n  init(initializer: InteractiveInit) {\n    initializer.hooks.configurePlugin.tapPromise(\"Example\", async (name) => {\n      if (name === \"my-plugins\") {\n        return [\n          name,\n          {\n            // extra config options\n          },\n        ];\n      }\n    });\n  }\n}\nclass MyPlugin implements IPlugin {\n  init(initializer: InteractiveInit) {\n    initializer.hooks.configurePlugin.tapPromise(\"Example\", async (name) => {\n      if (name === \"my-plugins\") {\n        return [\n          name,\n          {\n            // extra config options\n          },\n        ];\n      }\n    });\n  }\n}\n\nOther examples:\njira - Query the user for their JIRA url"
  },
  {
    "path": [
      "Plugin Authoring",
      "Init APIs",
      "createEnv"
    ],
    "url": "docs/plugins/init-hooks#createenv",
    "content": "\nAdd environment variables to get from the user.\nThese values are stored in a local .env file.\nclass MyPlugin implements IPlugin {\n  init(initializer: InteractiveInit) {\n    initializer.hooks.createEnv.tap(\"Example\", (vars) => [\n      ...vars,\n      {\n        variable: \"MY_TOKEN\",\n        message: `This is a very important secret`,\n      },\n    ]);\n  }\n}\nclass MyPlugin implements IPlugin {\n  init(initializer: InteractiveInit) {\n    initializer.hooks.createEnv.tap(\"Example\", (vars) => [\n      ...vars,\n      {\n        variable: \"MY_TOKEN\",\n        message: `This is a very important secret`,\n      },\n    ]);\n  }\n}\n\nOther examples:\nnpm - Query the user for their npm tokenslack - Query the user for their slack url"
  },
  {
    "path": [
      "Plugin Authoring",
      "Log Parser Hooks"
    ],
    "url": "docs/plugins/log-parse-hooks",
    "content": "\nThe core of auto is built around parsing information from the output of git log in your repository.\nWe take that output and iterate over it to extract information from the commits.\nThe construct that does that work is the LogParse class.\nThe LogParse class is involved in any command that interacts with the git log.\nYou can use its hooks to attach information to the commit object (parseCommit) or make auto ignore commits entirely (omitCommit).\nonCreateLogParseparseCommitomitCommit"
  },
  {
    "path": [
      "Plugin Authoring",
      "Log Parser Hooks",
      "onCreateLogParse"
    ],
    "url": "docs/plugins/log-parse-hooks#oncreatelogparse",
    "content": "\nThis is where you hook into the log parser's hooks.\nSee examples below."
  },
  {
    "path": [
      "Plugin Authoring",
      "Log Parser Hooks",
      "parseCommit"
    ],
    "url": "docs/plugins/log-parse-hooks#parsecommit",
    "content": "\nParse information about a commit from a commit.\nHere is where auto gets the PR number from the merge commits.\nauto.hooks.onCreateLogParse.tapPromise('Stars', logParse =>\n  logParse.hooks.parseCommit.tap(\n    'test',\n    (commit) => {\n      const bump = getBump(commit.subject, logParse.options.versionLabels);\n      commit.labels = [bump]\n      return commit;\n    }\n  );\n);\nauto.hooks.onCreateLogParse.tapPromise('Stars', logParse =>\n  logParse.hooks.parseCommit.tap(\n    'test',\n    (commit) => {\n      const bump = getBump(commit.subject, logParse.options.versionLabels);\n      commit.labels = [bump]\n      return commit;\n    }\n  );\n);\n\nOther examples:\nIn core:Find PR number from commits messageAttaches labels from pull requestsAttaches GitHub author informationconventional-commits - Parse change types from commit messages"
  },
  {
    "path": [
      "Plugin Authoring",
      "Log Parser Hooks",
      "omitCommit"
    ],
    "url": "docs/plugins/log-parse-hooks#omitcommit",
    "content": "\nChoose to omit certain commits.\nIf you return true the commit will be omitted.\nBe sure to return nothing if you don't want the commit omitted.\nauto.hooks.onCreateLogParse.tapPromise('Stars', changelog =>\n  changelog.hooks.omitCommit.tap(\n    'test',\n    (commit) => {\n      if (someTest(commit.subject)) {\n        return true;\n      }\n    }\n  );\n);\nauto.hooks.onCreateLogParse.tapPromise('Stars', changelog =>\n  changelog.hooks.omitCommit.tap(\n    'test',\n    (commit) => {\n      if (someTest(commit.subject)) {\n        return true;\n      }\n    }\n  );\n);\n\nOther examples:\ngradle - Omit commits from the Gradle Release pluginmaven - Omit commits from the Maven Release pluginomit-commit - Omit commits from authors, labels, and more"
  },
  {
    "path": [
      "Plugin Authoring",
      "Release Lifecycle Hooks"
    ],
    "url": "docs/plugins/release-lifecycle-hooks",
    "content": "\nThe following hooks are all called during various release commands (ex: latest, next, canary, shipit).\nThese hooks is where the publishing of your package actually happens.\nprCheckbeforeShipItbeforeCommitChangelogafterChangelogversionafterVersionpublishafterPublishcanarynextmakeReleaseafterReleaseafterShipIt"
  },
  {
    "path": [
      "Plugin Authoring",
      "Release Lifecycle Hooks",
      "prCheck"
    ],
    "url": "docs/plugins/release-lifecycle-hooks#prcheck",
    "content": "\nCalled before auto pr-check is ran/\nContext Object:\npr - All github information related to the PR\nauto.hooks.prCheck.tapPromise(\"NPM\", async ({ pr }) => {\n  // Do stuff\n});\nauto.hooks.prCheck.tapPromise(\"NPM\", async ({ pr }) => {\n  // Do stuff\n});\n"
  },
  {
    "path": [
      "Plugin Authoring",
      "Release Lifecycle Hooks",
      "beforeShipIt"
    ],
    "url": "docs/plugins/release-lifecycle-hooks#beforeshipit",
    "content": "\nHappens before shipit is run.\nThis is a great way to throw an error if a token or key is not present.\nContext Object:\nreleaseType (latest | old | next | canary) - The type of release shipit will attempt to make.dryRun - Whether the run is a dry run\nauto.hooks.beforeShipIt.tapPromise(\"NPM\", async (context) => {\n  if (!process.env.NPM_TOKEN) {\n    throw new Error(\"NPM Token is needed for the NPM plugin!\");\n  }\n});\nauto.hooks.beforeShipIt.tapPromise(\"NPM\", async (context) => {\n  if (!process.env.NPM_TOKEN) {\n    throw new Error(\"NPM Token is needed for the NPM plugin!\");\n  }\n});\n\nOther examples:\nall-contributors - Manage manual contribution additions in PRsgh-pages - Publishes your docs to GitHub pages on a latest releasenpm - Exits early when lerna won't need to make a release"
  },
  {
    "path": [
      "Plugin Authoring",
      "Release Lifecycle Hooks",
      "beforeCommitChangelog"
    ],
    "url": "docs/plugins/release-lifecycle-hooks#beforecommitchangelog",
    "content": "\nRan before the changelog command commits the new release notes to CHANGELOG.md.\nUseful for modifying the changelog as a whole or creating extra changelog files.\nThese files can be apart of the commit that updates the changelog.\nbump - the semver bumpcommits - the commits in the changelogcurrentVersion - version that was just releasedlastRelease - the version before the current versionreleaseNotes - generated release notes for the release\nauto.hooks.beforeCommitChangelog.tap(\n  \"MyPlugin\",\n  async ({ currentVersion, commits, releaseNotes, lastRelease }) => {\n    // do something\n  }\n);\nauto.hooks.beforeCommitChangelog.tap(\n  \"MyPlugin\",\n  async ({ currentVersion, commits, releaseNotes, lastRelease }) => {\n    // do something\n  }\n);\n\nOther examples:\nIn Core: Create major version branches when major happensnpm - Create sub-package changelogs"
  },
  {
    "path": [
      "Plugin Authoring",
      "Release Lifecycle Hooks",
      "afterChangelog"
    ],
    "url": "docs/plugins/release-lifecycle-hooks#afterchangelog",
    "content": "\nRan after the changelog command adds the new release notes to CHANGELOG.md.\nUseful for getting extra commits into a release before publishing.\nbump - the semver bumpcommits - the commits in the changelogcurrentVersion - version that was just releasedlastRelease - the version before the current versionreleaseNotes - generated release notes for the release\nauto.hooks.afterChangelog.tap(\n  \"MyPlugin\",\n  async ({ currentVersion, commits, releaseNotes, lastRelease }) => {\n    // do something\n  }\n);\nauto.hooks.afterChangelog.tap(\n  \"MyPlugin\",\n  async ({ currentVersion, commits, releaseNotes, lastRelease }) => {\n    // do something\n  }\n);\n\nOther examples:\nall-contributors - Make a commit for new contributions"
  },
  {
    "path": [
      "Plugin Authoring",
      "Release Lifecycle Hooks",
      "version"
    ],
    "url": "docs/plugins/release-lifecycle-hooks#version",
    "content": "\nIncrement the version the package.\nThis is a good opportunity to git tag the release also.\nThis hooks is required for plugin that facilitate publishing.\nHere npm does it for us.\nauto.hooks.version.tapPromise(\"NPM\", async ({ bump, dryRun, quiet }) => {\n  if (dryRun) {\n    const { version } = await loadPackageJson();\n    console.log(inc(version, bump));\n    return;\n  }\n\n  await execPromise(\"npm\", [\n    \"version\",\n    bump,\n    \"-m\",\n    \"Bump version to: %s [skip ci]\",\n  ]);\n});\nauto.hooks.version.tapPromise(\"NPM\", async ({ bump, dryRun, quiet }) => {\n  if (dryRun) {\n    const { version } = await loadPackageJson();\n    console.log(inc(version, bump));\n    return;\n  }\n\n  await execPromise(\"npm\", [\n    \"version\",\n    bump,\n    \"-m\",\n    \"Bump version to: %s [skip ci]\",\n  ]);\n});\n\nIf you're implementing this hook for a publishing plugin you must commit (with [skip ci] in the message) and tag the version."
  },
  {
    "path": [
      "Plugin Authoring",
      "Release Lifecycle Hooks",
      "afterVersion"
    ],
    "url": "docs/plugins/release-lifecycle-hooks#afterversion",
    "content": "\nRan after the package has been versioned.\nExamples:\nIn Core: Used to exit early is new commits are detected on the remotebrew - Create a new brew formula once the package a=has been versioned\nauto.hooks.afterVersion.tapPromise(\"NPM\", async ({ dryRun }) => {});\nauto.hooks.afterVersion.tapPromise(\"NPM\", async ({ dryRun }) => {});\n"
  },
  {
    "path": [
      "Plugin Authoring",
      "Release Lifecycle Hooks",
      "publish"
    ],
    "url": "docs/plugins/release-lifecycle-hooks#publish",
    "content": "\nPublish the package to some package distributor.\nYou must push the tags to github!\nThis hooks is required for plugin that facilitate publishing.\nauto.hooks.publish.tapPromise(\"NPM\", async ({ bump }) => {\n  await execPromise(\"npm\", [\n    \"version\",\n    bump,\n    \"-m\",\n    \"Bump version to: %s [skip ci]\",\n  ]);\n  await execPromise(\"npm\", [\"publish\"]);\n  await execPromise(\"git\", [\n    \"push\",\n    \"--follow-tags\",\n    \"--set-upstream\",\n    auto.remote,\n    \"$branch\",\n  ]);\n});\nauto.hooks.publish.tapPromise(\"NPM\", async ({ bump }) => {\n  await execPromise(\"npm\", [\n    \"version\",\n    bump,\n    \"-m\",\n    \"Bump version to: %s [skip ci]\",\n  ]);\n  await execPromise(\"npm\", [\"publish\"]);\n  await execPromise(\"git\", [\n    \"push\",\n    \"--follow-tags\",\n    \"--set-upstream\",\n    auto.remote,\n    \"$branch\",\n  ]);\n});\n"
  },
  {
    "path": [
      "Plugin Authoring",
      "Release Lifecycle Hooks",
      "afterPublish"
    ],
    "url": "docs/plugins/release-lifecycle-hooks#afterpublish",
    "content": "\nRan after the package has been published."
  },
  {
    "path": [
      "Plugin Authoring",
      "Release Lifecycle Hooks",
      "canary"
    ],
    "url": "docs/plugins/release-lifecycle-hooks#canary",
    "content": "\nUsed to publish a canary release.\nIn this hook you get the semver bump and the unique canary postfix ID.\nYou can either return a string value of just the version or an object containing the following which will be rendered within and HTML details element.\nnewVersion - The version published in the canary release or a header for the details element.details - The body of the details element\nauto.hooks.canary.tapPromise(\n  this.name,\n  async ({ bump, canaryIdentifier, dryRun, quiet }) => {\n    const lastRelease = await auto.git!.getLatestRelease();\n    const current = await auto.getCurrentVersion(lastRelease);\n    const nextVersion = inc(current, bump as ReleaseType);\n    const isScopedPackage = name.match(/@\\S+\\/\\S+/);\n    const canaryVersion = `${nextVersion}-canary${canaryIdentifier}`;\n\n    await execPromise(\"npm\", [\n      \"version\",\n      canaryVersion,\n      \"--no-git-tag-version\",\n    ]);\n    await execPromise(\"npm\", [\"publish\", \"--tag\", \"canary\"]);\n\n    auto.logger.verbose.info(\"Successfully published canary version\");\n    return canaryVersion;\n  }\n);\nauto.hooks.canary.tapPromise(\n  this.name,\n  async ({ bump, canaryIdentifier, dryRun, quiet }) => {\n    const lastRelease = await auto.git!.getLatestRelease();\n    const current = await auto.getCurrentVersion(lastRelease);\n    const nextVersion = inc(current, bump as ReleaseType);\n    const isScopedPackage = name.match(/@\\S+\\/\\S+/);\n    const canaryVersion = `${nextVersion}-canary${canaryIdentifier}`;\n\n    await execPromise(\"npm\", [\n      \"version\",\n      canaryVersion,\n      \"--no-git-tag-version\",\n    ]);\n    await execPromise(\"npm\", [\"publish\", \"--tag\", \"canary\"]);\n\n    auto.logger.verbose.info(\"Successfully published canary version\");\n    return canaryVersion;\n  }\n);\n\ncanary version should not produce any of the following:\na new tagany commitsa new releaseany changes to changelogs\nIt is \"test\" release and has no impact on any of your real releases."
  },
  {
    "path": [
      "Plugin Authoring",
      "Release Lifecycle Hooks",
      "next"
    ],
    "url": "docs/plugins/release-lifecycle-hooks#next",
    "content": "\nUsed to publish a next release.\nIn this hook you get the semver bump and a list of all pre-releases made.\nThis hook must add the version it published to preReleaseVersions and return it.\npreReleaseVersions - A list of prerelease version publish during the current runbump - The version bump to apply\nimport {\n  determineNextVersion,\n  execPromise,\n  getCurrentBranch,\n} from \"@auto-it/core\";\n\nauto.hooks.next.tapPromise(\n  this.name,\n  async (preReleaseVersions, { bump, dryRun }) => {\n    const branch = getCurrentBranch() || \"\";\n    const lastRelease = await auto.git.getLatestRelease();\n    const current =\n      (await auto.git.getLastTagNotInBaseBranch(branch)) ||\n      (await auto.getCurrentVersion(lastRelease));\n    // Use this helper function to determine the next prerelease version\n    const prerelease = determineNextVersion(lastRelease, current, bump, \"next\");\n\n    // Make sure to add the version to the list\n    preReleaseVersions.push(prerelease);\n\n    if (dryRun) {\n      return preReleaseVersions;\n    }\n\n    // Create a new tag for it\n    await execPromise(\"git\", [\n      \"tag\",\n      prerelease,\n      \"-m\",\n      `\"Tag pre-release: ${prerelease}\"`,\n    ]);\n    // Push the tag\n    await execPromise(\"git\", [\"push\", auto.remote, \"--tags\"]);\n\n    return preReleaseVersions;\n  }\n);\nimport {\n  determineNextVersion,\n  execPromise,\n  getCurrentBranch,\n} from \"@auto-it/core\";\n\nauto.hooks.next.tapPromise(\n  this.name,\n  async (preReleaseVersions, { bump, dryRun }) => {\n    const branch = getCurrentBranch() || \"\";\n    const lastRelease = await auto.git.getLatestRelease();\n    const current =\n      (await auto.git.getLastTagNotInBaseBranch(branch)) ||\n      (await auto.getCurrentVersion(lastRelease));\n    // Use this helper function to determine the next prerelease version\n    const prerelease = determineNextVersion(lastRelease, current, bump, \"next\");\n\n    // Make sure to add the version to the list\n    preReleaseVersions.push(prerelease);\n\n    if (dryRun) {\n      return preReleaseVersions;\n    }\n\n    // Create a new tag for it\n    await execPromise(\"git\", [\n      \"tag\",\n      prerelease,\n      \"-m\",\n      `\"Tag pre-release: ${prerelease}\"`,\n    ]);\n    // Push the tag\n    await execPromise(\"git\", [\"push\", auto.remote, \"--tags\"]);\n\n    return preReleaseVersions;\n  }\n);\n\nnext version should not produce any of the following:\nany commitsany changes to changelogs"
  },
  {
    "path": [
      "Plugin Authoring",
      "Release Lifecycle Hooks",
      "makeRelease"
    ],
    "url": "docs/plugins/release-lifecycle-hooks#makerelease",
    "content": "\nRan when trying to make a release during the release command has run.\nThis async hook gets the following arguments:\ndryRun - Whether this is a dry runfrom - Commit to start calculating the version fromnewVersion - The version being releasedisPrerelease - Whether the release being made is a prereleasefullReleaseNotes - The generated release notes for all of the commitscommits - The commits included in the release\nauto.hooks.makeRelease.tapPromise(\"MyPlugin\", async (options) => {\n  if (!options.dryRun) {\n    this.logger.log.info(`Releasing ${options.newVersion} to GitHub.`);\n\n    return this.git!.publish(\n      options.fullReleaseNotes,\n      options.newVersion,\n      options.isPrerelease\n    );\n  }\n});\nauto.hooks.makeRelease.tapPromise(\"MyPlugin\", async (options) => {\n  if (!options.dryRun) {\n    this.logger.log.info(`Releasing ${options.newVersion} to GitHub.`);\n\n    return this.git!.publish(\n      options.fullReleaseNotes,\n      options.newVersion,\n      options.isPrerelease\n    );\n  }\n});\n\nOther examples:\nnpm - Create GitHub releases for sub-packages"
  },
  {
    "path": [
      "Plugin Authoring",
      "Release Lifecycle Hooks",
      "afterRelease"
    ],
    "url": "docs/plugins/release-lifecycle-hooks#afterrelease",
    "content": "\nRan after the release command has run, creating a new release on GitHub.\nThis async hook gets the following arguments:\nlastRelease - the version that existed prior to the current releasenewVersion - version that was just releasedcommits - the commits in the releasereleaseNotes - generated release notes for the releaseresponse - the response returned from making the release\nauto.hooks.afterRelease.tapPromise(\n  \"MyPlugin\",\n  async ({ lastRelease, newVersion, commits, releaseNotes, response }) => {\n    // do something\n  }\n);\nauto.hooks.afterRelease.tapPromise(\n  \"MyPlugin\",\n  async ({ lastRelease, newVersion, commits, releaseNotes, response }) => {\n    // do something\n  }\n);\n\nOther examples:\nrelease - Post comment on issues and PRs about release versions3 - Upload release assets to s3slack - Post the release notes to slacktwitter - Create a tweet about the new releaseupload-assets - Uses hook to upload files to newly created release"
  },
  {
    "path": [
      "Plugin Authoring",
      "Release Lifecycle Hooks",
      "afterShipIt"
    ],
    "url": "docs/plugins/release-lifecycle-hooks#aftershipit",
    "content": "\nRan after the shipit command has run.\ndatanewVersion - The new version that was releasecommits - the commits in the releasecontext - The type of release that was created (latest, next, canary, or old)dryRun - Whether the run is a dry run\nauto.hooks.afterShipIt.tap(\"MyPlugin\", async ({ context }) => {\n  // do something\n});\nauto.hooks.afterShipIt.tap(\"MyPlugin\", async ({ context }) => {\n  // do something\n});\n\nOther examples:\ngradle - Uses hook to setup next snapshot version"
  },
  {
    "path": [
      "Plugin Authoring",
      "Writing Plugins"
    ],
    "url": "docs/plugins/writing-plugins",
    "content": "\nIf you've ever written a webpack plugin it's a lot like that.\nA plugin definition is:\na name for the plugin, should match the name of the package (REQUIRED)a class the has an apply function where a plugin hooks into various functions in auto (REQUIRED)\nYou can write a plugin directly in TypeScript with no build step:\nimport { Auto, IPlugin } from \"auto\";\n\nexport default class TestPlugin implements IPlugin {\n  name = \"test\";\n\n  /** Tap into auto plugin points. */\n  apply(auto: Auto) {}\n}\nimport { Auto, IPlugin } from \"auto\";\n\nexport default class TestPlugin implements IPlugin {\n  name = \"test\";\n\n  /** Tap into auto plugin points. */\n  apply(auto: Auto) {}\n}\n\nOr in JavaScript:\nmodule.exports = class TestPlugin {\n  constructor() {\n    this.name = \"test\";\n  }\n\n  /**\n   * Tap into auto plugin points.\n   * @param {import('@auto-it/core').default} auto\n   */\n  apply(auto) {}\n};\nmodule.exports = class TestPlugin {\n  constructor() {\n    this.name = \"test\";\n  }\n\n  /**\n   * Tap into auto plugin points.\n   * @param {import('@auto-it/core').default} auto\n   */\n  apply(auto) {}\n};\n"
  },
  {
    "path": [
      "Plugin Authoring",
      "Writing Plugins",
      "Hooks"
    ],
    "url": "docs/plugins/writing-plugins#hooks",
    "content": "\nPlugins work by hooking into various actions that auto has to do in order to facilitate a release or interact with your GitHub repo.\nRead more about using hooks"
  },
  {
    "path": [
      "Plugin Authoring",
      "Writing Plugins",
      "Adding Options"
    ],
    "url": "docs/plugins/writing-plugins#adding-options",
    "content": "\nMost plugins will find the need to some some options from the user.\nThe constructor of the plugin gets access to the options passed in the .autorc.\nimport { Auto, IPlugin } from \"@auto-it/core\";\n\ninterface TestPluginOptions {\n  someOption?: boolean;\n}\n\nexport default class TestPlugin implements IPlugin {\n  /** The name of the plugin */\n  name = \"test\";\n\n  /** The options of the plugin */\n  readonly options: TestPluginOptions;\n\n  /** Initialize the plugin with it's options */\n  constructor(options: TestPluginOptions) {\n    this.options = options;\n  }\n}\nimport { Auto, IPlugin } from \"@auto-it/core\";\n\ninterface TestPluginOptions {\n  someOption?: boolean;\n}\n\nexport default class TestPlugin implements IPlugin {\n  /** The name of the plugin */\n  name = \"test\";\n\n  /** The options of the plugin */\n  readonly options: TestPluginOptions;\n\n  /** Initialize the plugin with it's options */\n  constructor(options: TestPluginOptions) {\n    this.options = options;\n  }\n}\n"
  },
  {
    "path": [
      "Plugin Authoring",
      "Writing Plugins",
      "Adding Options",
      "Validation"
    ],
    "url": "docs/plugins/writing-plugins#validation",
    "content": "\nTo get validate of the options passed to plugins, auto uses io-ts and exports a utility function to validate the structured produced by io-ts.\nIt lets you defined your interfaces in JavaScript and easily convert them to TypeScript.\nThis means it's super simple to have type-safe code and runtime validation checking!\nFirst install the following:\nnpm i --save io-ts fp-ts\n# or\nyarn add io-ts fp-ts\nnpm i --save io-ts fp-ts\n# or\nyarn add io-ts fp-ts\n\nThen convert your options interface to the equivalent io-ts structure.\nimport * as t from \"io-ts\";\n\nconst pluginOptions = t.partial({\n  someOption: t.boolean,\n});\n\nexport type TestPluginOptions = t.TypeOf<typeof pluginOptions>;\nimport * as t from \"io-ts\";\n\nconst pluginOptions = t.partial({\n  someOption: t.boolean,\n});\n\nexport type TestPluginOptions = t.TypeOf<typeof pluginOptions>;\n\nThen tap into the validateConfig hook and use the validatePluginConfiguration utility.\nimport { validatePluginConfiguration } from \"@auto-it/core\";\n\nexport default class MyPlugin implements IPlugin {\n  // ...\n  apply(auto: Auto) {\n    auto.hooks.validateConfig.tapPromise(this.name, async (name, options) => {\n      if (name === this.name || name === `auto-plugin-${this.name}`) {\n        return validatePluginConfiguration(this.name, pluginOptions, options);\n      }\n    });\n  }\n}\nimport { validatePluginConfiguration } from \"@auto-it/core\";\n\nexport default class MyPlugin implements IPlugin {\n  // ...\n  apply(auto: Auto) {\n    auto.hooks.validateConfig.tapPromise(this.name, async (name, options) => {\n      if (name === this.name || name === `auto-plugin-${this.name}`) {\n        return validatePluginConfiguration(this.name, pluginOptions, options);\n      }\n    });\n  }\n}\n\nAnd that's it!\nNow auto will validate your plugins configuration before running."
  },
  {
    "path": [
      "Plugin Authoring",
      "Writing Plugins",
      "Example Plugin - NPM (simple)"
    ],
    "url": "docs/plugins/writing-plugins#example-plugin---npm-simple",
    "content": "\nTo create a plugin simply make a class with an apply method and tap into the hooks you need.\nimport * as fs from \"fs\";\nimport { promisify } from \"util\";\n\nimport { IAutoHooks, Auto, SEMVER, execPromise } from \"auto\";\nimport getConfigFromPackageJson from \"./package-config\";\n\nconst readFile = promisify(fs.readFile);\n\nexport default class NPMPlugin {\n  public apply(auto: Auto) {\n    auto.hooks.getAuthor.tapPromise(\"NPM\", async () => {\n      const { author } = JSON.parse(await readFile(\"package.json\", \"utf-8\"));\n\n      if (author) {\n        auto.logger.log.info(\"NPM: Got author information from package.json\");\n        return author;\n      }\n    });\n\n    auto.hooks.getPreviousVersion.tapPromise(\"NPM\", async () => {\n      const { version } = JSON.parse(await readFile(\"package.json\", \"utf-8\"));\n\n      auto.logger.log.info(\n        \"NPM: Got previous version from package.json - \",\n        version\n      );\n\n      if (version) {\n        return auto.prefixRelease(\n          JSON.parse(await readFile(\"package.json\", \"utf-8\")).version\n        );\n      }\n    });\n\n    auto.hooks.getRepository.tapPromise(\"NPM\", async () => {\n      auto.logger.log.info(\"NPM: getting repo information from package.json\");\n      return getConfigFromPackageJson();\n    });\n\n    auto.hooks.publish.tapPromise(\"NPM\", async (version: SEMVER) => {\n      await execPromise(\"npm\", [\n        \"version\",\n        version,\n        \"-m\",\n        \"Bump version to: %s [skip ci]\",\n      ]);\n      await execPromise(\"npm\", [\"publish\"]);\n      await execPromise(\"git\", [\n        \"push\",\n        \"--follow-tags\",\n        \"--set-upstream\",\n        auto.remote,\n        \"$branch\",\n      ]);\n    });\n  }\n}\nimport * as fs from \"fs\";\nimport { promisify } from \"util\";\n\nimport { IAutoHooks, Auto, SEMVER, execPromise } from \"auto\";\nimport getConfigFromPackageJson from \"./package-config\";\n\nconst readFile = promisify(fs.readFile);\n\nexport default class NPMPlugin {\n  public apply(auto: Auto) {\n    auto.hooks.getAuthor.tapPromise(\"NPM\", async () => {\n      const { author } = JSON.parse(await readFile(\"package.json\", \"utf-8\"));\n\n      if (author) {\n        auto.logger.log.info(\"NPM: Got author information from package.json\");\n        return author;\n      }\n    });\n\n    auto.hooks.getPreviousVersion.tapPromise(\"NPM\", async () => {\n      const { version } = JSON.parse(await readFile(\"package.json\", \"utf-8\"));\n\n      auto.logger.log.info(\n        \"NPM: Got previous version from package.json - \",\n        version\n      );\n\n      if (version) {\n        return auto.prefixRelease(\n          JSON.parse(await readFile(\"package.json\", \"utf-8\")).version\n        );\n      }\n    });\n\n    auto.hooks.getRepository.tapPromise(\"NPM\", async () => {\n      auto.logger.log.info(\"NPM: getting repo information from package.json\");\n      return getConfigFromPackageJson();\n    });\n\n    auto.hooks.publish.tapPromise(\"NPM\", async (version: SEMVER) => {\n      await execPromise(\"npm\", [\n        \"version\",\n        version,\n        \"-m\",\n        \"Bump version to: %s [skip ci]\",\n      ]);\n      await execPromise(\"npm\", [\"publish\"]);\n      await execPromise(\"git\", [\n        \"push\",\n        \"--follow-tags\",\n        \"--set-upstream\",\n        auto.remote,\n        \"$branch\",\n      ]);\n    });\n  }\n}\n\nRead more about creating publishing plugins."
  },
  {
    "path": [
      "Plugin Authoring",
      "Writing a Publishing Plugin"
    ],
    "url": "docs/plugins/writing-publishing-plugins",
    "content": "\nThe main use for plugins is to automate your release process.\nThis page will walk you through implementing the git-tag plugin.\nIt is recommended that you use TypeScript for the best development experience.\nauto is written in TypeScript and has extensive jsDoc comments throughout the code.\nTo make the following code work without compilation, just remove the types!"
  },
  {
    "path": [
      "Plugin Authoring",
      "Writing a Publishing Plugin",
      "Setup"
    ],
    "url": "docs/plugins/writing-publishing-plugins#setup",
    "content": "\nFirst create a file for your plugins.\nMake sure to set the name! It must be consistent with your packages name.\nmy-plugin.ts:\nimport { Auto, IPlugin } from \"@auto-it/core\";\n\nexport default class GitTagPlugin implements IPlugin {\n  /** The name of the plugin */\n  name = \"my-git-tag\";\n\n  /** Tap into auto plugin points. */\n  apply(auto: Auto) {}\n}\nimport { Auto, IPlugin } from \"@auto-it/core\";\n\nexport default class GitTagPlugin implements IPlugin {\n  /** The name of the plugin */\n  name = \"my-git-tag\";\n\n  /** Tap into auto plugin points. */\n  apply(auto: Auto) {}\n}\n"
  },
  {
    "path": [
      "Plugin Authoring",
      "Writing a Publishing Plugin",
      "Tap Required Hooks"
    ],
    "url": "docs/plugins/writing-publishing-plugins#tap-required-hooks",
    "content": "\nPlugins work by \"hooking\" into various parts of auto to control or add to its behavior.\nThe following hooks you must implement to get a publishing plugin working."
  },
  {
    "path": [
      "Plugin Authoring",
      "Writing a Publishing Plugin",
      "Tap Required Hooks",
      "getPreviousVersion"
    ],
    "url": "docs/plugins/writing-publishing-plugins#getpreviousversion",
    "content": "\nThis plugin will manage the version of the project solely using the tag.\nSet up this hook to tell auto the last release version of your project\nexport default class GitTagPlugin implements IPlugin {\n  // ...\n  apply(auto: Auto) {\n    /** Get the latest tag in the repo, if none then the first commit */\n    async function getTag() {\n      try {\n        return await auto.git!.getLatestTagInBranch();\n      } catch (error) {\n        return auto.prefixRelease(\"0.0.0\");\n      }\n    }\n\n    auto.hooks.getPreviousVersion.tapPromise(this.name, getTag);\n  }\n}\nexport default class GitTagPlugin implements IPlugin {\n  // ...\n  apply(auto: Auto) {\n    /** Get the latest tag in the repo, if none then the first commit */\n    async function getTag() {\n      try {\n        return await auto.git!.getLatestTagInBranch();\n      } catch (error) {\n        return auto.prefixRelease(\"0.0.0\");\n      }\n    }\n\n    auto.hooks.getPreviousVersion.tapPromise(this.name, getTag);\n  }\n}\n"
  },
  {
    "path": [
      "Plugin Authoring",
      "Writing a Publishing Plugin",
      "Tap Required Hooks",
      "version"
    ],
    "url": "docs/plugins/writing-publishing-plugins#version",
    "content": "\nIn this hook you should increment the version of your project, tag it, and if necessary commit a file (ex: package.json).\nimport { inc, ReleaseType } from \"semver\";\n\nexport default class GitTagPlugin implements IPlugin {\n  // ...\n  apply(auto: Auto) {\n    // ...\n    auto.hooks.version.tapPromise(this.name, async ({ bump }) => {\n      const lastTag = await getTag();\n      const newTag = inc(lastTag, version as ReleaseType);\n\n      if (newTag && dryRun) {\n        console.log(newTag);\n        return;\n      }\n\n      if (!newTag) {\n        auto.logger.log.info(\"No release found, doing nothing\");\n        return;\n      }\n\n      const prefixedTag = auto.prefixRelease(newTag);\n\n      auto.logger.log.info(`Tagging new tag: ${lastTag} => ${prefixedTag}`);\n      await execPromise(\"git\", [\n        \"tag\",\n        prefixedTag,\n        \"-m\",\n        `\"Update version to ${prefixedTag}\"`,\n      ]);\n    });\n  }\n}\nimport { inc, ReleaseType } from \"semver\";\n\nexport default class GitTagPlugin implements IPlugin {\n  // ...\n  apply(auto: Auto) {\n    // ...\n    auto.hooks.version.tapPromise(this.name, async ({ bump }) => {\n      const lastTag = await getTag();\n      const newTag = inc(lastTag, version as ReleaseType);\n\n      if (newTag && dryRun) {\n        console.log(newTag);\n        return;\n      }\n\n      if (!newTag) {\n        auto.logger.log.info(\"No release found, doing nothing\");\n        return;\n      }\n\n      const prefixedTag = auto.prefixRelease(newTag);\n\n      auto.logger.log.info(`Tagging new tag: ${lastTag} => ${prefixedTag}`);\n      await execPromise(\"git\", [\n        \"tag\",\n        prefixedTag,\n        \"-m\",\n        `\"Update version to ${prefixedTag}\"`,\n      ]);\n    });\n  }\n}\n"
  },
  {
    "path": [
      "Plugin Authoring",
      "Writing a Publishing Plugin",
      "Tap Required Hooks",
      "publish"
    ],
    "url": "docs/plugins/writing-publishing-plugins#publish",
    "content": "\nFinally publish your new version to a package management platform and push the new tag to GitHub.\nIn the case of the git-tag plugin pushing the tag to GitHub is the only thing we need to do.\nexport default class GitTagPlugin implements IPlugin {\n  // ...\n  apply(auto: Auto) {\n    // ...\n    auto.hooks.publish.tapPromise(this.name, async () => {\n      auto.logger.log.info(\"Pushing new tag to GitHub\");\n\n      await execPromise(\"git\", [\n        \"push\",\n        \"--follow-tags\",\n        \"--set-upstream\",\n        auto.remote,\n        getCurrentBranch() || auto.baseBranch,\n      ]);\n    });\n  }\n}\nexport default class GitTagPlugin implements IPlugin {\n  // ...\n  apply(auto: Auto) {\n    // ...\n    auto.hooks.publish.tapPromise(this.name, async () => {\n      auto.logger.log.info(\"Pushing new tag to GitHub\");\n\n      await execPromise(\"git\", [\n        \"push\",\n        \"--follow-tags\",\n        \"--set-upstream\",\n        auto.remote,\n        getCurrentBranch() || auto.baseBranch,\n      ]);\n    });\n  }\n}\n\n\nOnce you have the above hooks implemented you should be able to successfully use auto to publish a release!\nThe above plugins is pretty simple and there are a bunch of features you can add to your plugin through hooks or functions that auto exports."
  },
  {
    "path": [
      "Plugin Authoring",
      "Writing a Publishing Plugin",
      "Advanced Release Hooks"
    ],
    "url": "docs/plugins/writing-publishing-plugins#advanced-release-hooks",
    "content": ""
  },
  {
    "path": [
      "Plugin Authoring",
      "Writing a Publishing Plugin",
      "Advanced Release Hooks",
      "canary"
    ],
    "url": "docs/plugins/writing-publishing-plugins#canary",
    "content": "\nThis hook enables canary releases for your projects.\nA canary version is a test version you publish for PRs or to test changes.\nYour package management platform needs to support a few things for canaries to be possible\nSeparate Releases Lines - you should be able to publish to a release line that doesn't effect your main users (ex: when installing for the first time they should never get a canary)Lots of releases - it must support a lot of releases, especially if you make a bunch of PRs\nRead more about the canary hook."
  },
  {
    "path": [
      "Plugin Authoring",
      "Writing a Publishing Plugin",
      "Advanced Release Hooks",
      "next"
    ],
    "url": "docs/plugins/writing-publishing-plugins#next",
    "content": "\nThis hook enables next releases for your projects.\nA next release is the next version of your project.\nThink of it like an alpha or beta release line.\nLike the canary hook your package management platform must support separate release lines.\nRead more about the next hook."
  },
  {
    "path": [
      "Plugin Authoring",
      "Writing a Publishing Plugin",
      "Other Useful Hooks"
    ],
    "url": "docs/plugins/writing-publishing-plugins#other-useful-hooks",
    "content": "\nThese hooks are not required for publishing plugins, but can really improve the developer experience of it."
  },
  {
    "path": [
      "Plugin Authoring",
      "Writing a Publishing Plugin",
      "Other Useful Hooks",
      "beforeRun"
    ],
    "url": "docs/plugins/writing-publishing-plugins#beforerun",
    "content": "\nHappens before anything is done.\nThis is a great place to check for platform specific secrets such as a npm token.\nexport default class GitTagPlugin implements IPlugin {\n  // ...\n  apply(auto: Auto) {\n    auto.hooks.beforeRun.tap(this.name, () => {\n      // Use the `checkEnv` function to warn about missing ENV variables\n      auto.checkEnv(this.name, \"CLIENT_ID\");\n    });\n  }\n}\nexport default class GitTagPlugin implements IPlugin {\n  // ...\n  apply(auto: Auto) {\n    auto.hooks.beforeRun.tap(this.name, () => {\n      // Use the `checkEnv` function to warn about missing ENV variables\n      auto.checkEnv(this.name, \"CLIENT_ID\");\n    });\n  }\n}\n"
  },
  {
    "path": [
      "Plugin Authoring",
      "Writing a Publishing Plugin",
      "Other Useful Hooks",
      "getAuthor"
    ],
    "url": "docs/plugins/writing-publishing-plugins#getauthor",
    "content": "\nGet git author to commit with.\nTypically from a package distribution description file.\nauto.hooks.getAuthor.tapPromise(\"NPM\", async () => {\n  const { author } = JSON.parse(await readFile(\"package.json\", \"utf-8\"));\n\n  if (author) {\n    return author;\n  }\n});\nauto.hooks.getAuthor.tapPromise(\"NPM\", async () => {\n  const { author } = JSON.parse(await readFile(\"package.json\", \"utf-8\"));\n\n  if (author) {\n    return author;\n  }\n});\n"
  },
  {
    "path": [
      "Plugin Authoring",
      "Writing a Publishing Plugin",
      "Other Useful Hooks",
      "getRepository"
    ],
    "url": "docs/plugins/writing-publishing-plugins#getrepository",
    "content": "\nGet owner and repository for the project to automate releases for.\nTypically from a package distribution description file.\nFalls back to global git config author.\nauto.hooks.getRepository.tapPromise('NPM', async () => {\n  const owner = // get the owner from package.json\n  const repo = // get the repo from package.json\n\n  return {\n    owner,\n    repo\n  }\n});\nauto.hooks.getRepository.tapPromise('NPM', async () => {\n  const owner = // get the owner from package.json\n  const repo = // get the repo from package.json\n\n  return {\n    owner,\n    repo\n  }\n});\n"
  },
  {
    "path": [
      "Welcome",
      "Getting Started"
    ],
    "url": "docs/welcome/getting-started",
    "content": "\nBefore we do anything we must first install auto as a dev dependency.\nyarn add -D auto\nyarn add -D auto\n\nIf you are using auto in a non-javascript project, you can install auto and all it's official plugins via the releases page. Here you will find a build of auto for all major OSes. This build has node bundled so you don't need it installed!\n⚠️ If you use yarn@2 none of the default plugins (npm and released) are included so you must install them if you want to use them."
  },
  {
    "path": [
      "Welcome",
      "Getting Started",
      "Help"
    ],
    "url": "docs/welcome/getting-started#help",
    "content": "\nTo get detailed help for any command use the --help flag.\nauto --help\n# or any of auto's command's help\nauto shipit --help\nauto --help\n# or any of auto's command's help\nauto shipit --help\n"
  },
  {
    "path": [
      "Welcome",
      "Getting Started",
      "Help",
      "Make \"Latest Release\""
    ],
    "url": "docs/welcome/getting-started#make-latest-release",
    "content": "\nIf your project is already published then you need to make sure that your last release is tagged and that it's the Latest Release on GitHub.\nTo tag your last release find that last commit where you bumped the version and run the following commands with your version number.\ngit tag v1.2.3\ngit push --tags\ngit tag v1.2.3\ngit push --tags\n\nThen on GitHub go to your project's releases and click Draft a new release.\nIn the Tag version field enter the version number you just tagged and click Publish release.\nNow your github project is set up to use auto 🎉"
  },
  {
    "path": [
      "Welcome",
      "Getting Started",
      "Configuration"
    ],
    "url": "docs/welcome/getting-started#configuration",
    "content": "\nGetting started with auto is super easy.\nInitialize Options (optional)Configure Environment VariablesCreate LabelsRun auto"
  },
  {
    "path": [
      "Welcome",
      "Getting Started",
      "Configuration",
      "1. Initialize Options Optional"
    ],
    "url": "docs/welcome/getting-started#1-initialize-options-optional",
    "content": "\nInitialize the bare minimum options and a few other optional things.\nThis will set you up locally but you will still have to configure environment variables in your CI.\nauto init\nauto init\n"
  },
  {
    "path": [
      "Welcome",
      "Getting Started",
      "Configuration",
      "2. Configure Environment Variables"
    ],
    "url": "docs/welcome/getting-started#2-configure-environment-variables",
    "content": "\nYou must configure some environment variables for publishing and releasing to work properly.\nGH_TOKEN - Used for publishing the GitHub release and creating labels (create one here) (needs repo permission)\nMake sure you give the GH_TOKEN repo permission or shipit will fail!"
  },
  {
    "path": [
      "Welcome",
      "Getting Started",
      "Configuration",
      "2. Configure Environment Variables",
      "Local .env Recommended"
    ],
    "url": "docs/welcome/getting-started#local-env-recommended",
    "content": "\nYou can also store these values in a local file at the root of your project named .env.\nYou should make sure to add this file to your .gitignore so you don't commit any keys!\nThese env vars will override these any variable already set on the process.\nThis enables you to have a per project configuration that isn't effected by your global setup.\nPROJECT_ROOT/.env:\nGH_TOKEN=YOUR_TOKEN\nNPM_TOKEN=PUBLISH_TOKEN\nGH_TOKEN=YOUR_TOKEN\nNPM_TOKEN=PUBLISH_TOKEN\n"
  },
  {
    "path": [
      "Welcome",
      "Getting Started",
      "Configuration",
      "2. Configure Environment Variables",
      "HTTP Proxy"
    ],
    "url": "docs/welcome/getting-started#http-proxy",
    "content": "\nIf you are running auto behind a http or https proxy, add either the http_proxy or https_proxy environment variable to your environment.\nTo test locally add it to .env file.\nRemember this file is only local, so you will need to set the variable in your CI as well.\nhttps_proxy=<PROXYHOST>:<PROXYPORT>\nhttps_proxy=<PROXYHOST>:<PROXYPORT>\n"
  },
  {
    "path": [
      "Welcome",
      "Getting Started",
      "Configuration",
      "3. Create Labels"
    ],
    "url": "docs/welcome/getting-started#3-create-labels",
    "content": "\nAfter that, you need to set up the labels on your GitHub project.\nThe types of labels that auto uses are:\nVersioning Labels - Used to calculate version numbers and make releases. To change them refer to this.Changelog Labels - These labels do not effect the version calculation but they will change the section the PR displays in the changelog. These are customizable too, and you can even add your own sections.\nTo create the labels for your project on GitHub, run the following command with your GH_TOKEN.\nGH_TOKEN=YOUR_TOKEN auto create-labels\n# or with .env file\nauto create-labels\nGH_TOKEN=YOUR_TOKEN auto create-labels\n# or with .env file\nauto create-labels\n"
  },
  {
    "path": [
      "Welcome",
      "Getting Started",
      "Configuration",
      "4. Run auto"
    ],
    "url": "docs/welcome/getting-started#4-run-auto",
    "content": "\nauto is written so that each tool it exposes is useful in isolation.\nYou can use as much or as little of auto as you want!\nThere are two ways you can use auto to create releases.\nauto shipit - Let auto do everythingSub Commands - Run each command yourself"
  },
  {
    "path": [
      "Welcome",
      "Getting Started",
      "Configuration",
      "4. Run auto",
      "auto shipit Recommended"
    ],
    "url": "docs/welcome/getting-started#auto-shipit-recommended",
    "content": "\nTo version, changelog, publish and release your code all at the same time you should use the shipit command.\nshipit runs all commands in the auto workflow and puts it into one meta-command.\nIt's context aware and will make different types of releases based on where you run it.\nRead more here.\n{\n  \"scripts\": {\n    \"release\": \"auto shipit\"\n  }\n}\n{\n  \"scripts\": {\n    \"release\": \"auto shipit\"\n  }\n}\n"
  },
  {
    "path": [
      "Welcome",
      "Getting Started",
      "Configuration",
      "4. Run auto",
      "Do-It-Yourself"
    ],
    "url": "docs/welcome/getting-started#do-it-yourself",
    "content": "\nAll of the functionality of shipit is accessible through all of auto's other commands.\nThrough these commands you can fit parts of auto into your existing release process.\n{\n  \"scripts\": {\n    \"release\": \"./scripts/release.sh\"\n  }\n}\n{\n  \"scripts\": {\n    \"release\": \"./scripts/release.sh\"\n  }\n}\n\nHere is an example release script for a npm package:\nexport PATH=$(npm bin):$PATH\n\nVERSION=`auto version`\n\n## Support for label 'skip-release'\nif [ ! -z \"$VERSION\" ]; then\n  ## Update Changelog\n  auto changelog\n\n  ## Publish Package\n  npm version $VERSION -m \"Bump version to: %s [skip ci]\"\n  npm publish\n\n  ## Create GitHub Release\n  git push --follow-tags --set-upstream origin $branch\n  auto release\nfi\nexport PATH=$(npm bin):$PATH\n\nVERSION=`auto version`\n\n## Support for label 'skip-release'\nif [ ! -z \"$VERSION\" ]; then\n  ## Update Changelog\n  auto changelog\n\n  ## Publish Package\n  npm version $VERSION -m \"Bump version to: %s [skip ci]\"\n  npm publish\n\n  ## Create GitHub Release\n  git push --follow-tags --set-upstream origin $branch\n  auto release\nfi\n"
  },
  {
    "path": [
      "Welcome",
      "Getting Started",
      "Enterprise"
    ],
    "url": "docs/welcome/getting-started#enterprise",
    "content": "\nIf you are using enterprise github auto lets you configure the github API URL that it uses. You can configure this by using the CLI option --github-api, by setting the value in your .autorc, or during auto init."
  },
  {
    "path": [
      "Welcome",
      "Merging Quickly"
    ],
    "url": "docs/welcome/quick-merge",
    "content": "\nOne caveat of auto is that you need to be mindful of merging multiple PRs at once.\nYou must not merge a PR while another is publishing (ex: during lerna publish).\nWhile this window is small, it exists and you should know about it.\nauto works by looking at the git tree to calculate the version bump then makes commits for the CHANGELOG.md and the new version.\nIf you merge a PR while another is publishing:\nthey might try to publish the same version numberone will try to push over the other's changes and fail\nIf you ensure that the last build on baseBrach has finished you shouldn't run into any problems!"
  },
  {
    "path": [
      "Welcome",
      "Merging Quickly",
      "With skip-release"
    ],
    "url": "docs/welcome/quick-merge#with-skip-release",
    "content": "\nThe one exception to this rule with when merging a bunch of PRs with skip-release labels.\nYou still can't merge a PR that triggers a release and then merge a PR with skip-release.\nThis will result in problem 3 from above.\n1. Merge PR #4 \"patch\"\n2. Merge PR #5 \"skip-release\"\n\nResult: #4 tries to push commits over #5 and fails\n1. Merge PR #4 \"patch\"\n2. Merge PR #5 \"skip-release\"\n\nResult: #4 tries to push commits over #5 and fails\n\nBut you can merge a bunch of PRs with skip-release then merge a PR that triggers a release.\n1. Merge PR #4 \"skip-release\"\n2. Merge PR #5 \"skip-release\"\n3. Merge PR #7 \"patch\"\n\nResult: 1 \"patch\" released w/all PRs\n1. Merge PR #4 \"skip-release\"\n2. Merge PR #5 \"skip-release\"\n3. Merge PR #7 \"patch\"\n\nResult: 1 \"patch\" released w/all PRs\n\nBecause skip-release is present no commits are made and the release is fine!"
  }
]