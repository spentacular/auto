_N_E=(window.webpackJsonp_N_E=window.webpackJsonp_N_E||[]).push([[21],{EyFH:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/blog/why",function(){return n("Q80F")}])},Q80F:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return d})),n.d(t,"default",(function(){return m}));var a=n("Fcif"),o=n("dV/x"),i=n("mXGw"),s=n.n(i),r=n("/FXl"),l=n("sQxV"),u=n.n(l),d=(s.a.createElement,{image:"https://cdn-images-1.medium.com/max/800/1*TVSbt7qsyleNiQ84la_log.jpeg",title:"Death to Monotony",author:"Adam Dierkens",url:"https://github.intuit.com/adierkens",date:"Thu, 12 Mar 2020 23:00:02 -0700",layout:"blog",description:"I've been a front-end engineer at Intuit in San Diego for the past three years.\nAs one of three members of Intuit's Player team, we are responsible for delivering a JavaScript framework dedicated to rendering most of a user's experience in [TurboTax](https://turbotax.intuit.com/).\nWe end up releasing a lot of code, usually React components, quite frequently to our internal node package manager (npm) instance.\nIt's not uncommon for us to hit double-digit releases in a single day.\nThis means lots of version bumps, release notes, changelogs, Jira tickets, Slack announcements, and all the other goodies that come with communicating to dependent teams, that their bug is now fixed, or a new feature is ready for them to use.\nWhile none of these steps are intrinsically difficult, the time commitment adds up quickly, so we wrote auto: a tool to [auto-generate releases based on semantic version labels](https://github.com/intuit/auto).\n",email:"",__resourcePath:"blog/why.mdx",__scans:{}}),h={frontMatter:d},c=u.a;function m(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(r.mdx)(c,Object(a.a)({},h,n,{components:t,mdxType:"MDXLayout"}),Object(r.mdx)("h1",{id:"how-auto-can-handle-the-rest-for-you"},Object(r.mdx)("a",Object(a.a)({parentName:"h1"},{className:'header-link no-underline text-gray-900" hover:underline',href:"#how-auto-can-handle-the-rest-for-you"}),'How auto can "handle the rest for you"')),Object(r.mdx)("p",null,"I've been a front-end engineer at Intuit in San Diego for the past three years.\nAs one of three members of Intuit's Player team, we are responsible for delivering a JavaScript framework dedicated to rendering most of a user's experience in ",Object(r.mdx)("a",Object(a.a)({parentName:"p"},{href:"https://turbotax.intuit.com/"}),"TurboTax"),".\nWe end up releasing a lot of code, usually React components, quite frequently to our internal node package manager (npm) instance.\nIt's not uncommon for us to hit double-digit releases in a single day.\nThis means lots of version bumps, release notes, changelogs, Jira tickets, Slack announcements, and all the other goodies that come with communicating to dependent teams, that their bug is now fixed, or a new feature is ready for them to use.\nWhile none of these steps are intrinsically difficult, the time commitment adds up quickly, so we wrote auto: a tool to ",Object(r.mdx)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/intuit/auto"}),"auto-generate releases based on semantic version labels"),"."),Object(r.mdx)("hr",null),Object(r.mdx)("h2",{id:"the-problem"},Object(r.mdx)("a",Object(a.a)({parentName:"h2"},{className:'header-link no-underline text-gray-900" hover:underline',href:"#the-problem"}),"The Problem")),Object(r.mdx)("p",null,"Historically, our release process involved a lot of manual labor.\nBefore publishing an update to npm, someone on the team had to gather all of the changes merged since our last release, write up a changelog, and figure out what the next version was going to be.\nThis often involved a lot of back and forth between GitHub and Jira.\nOnce we had all of that, we could create a release, publish it to npm, document it in GitHub, and post an update to our team's Slack channel.\nThese 6-7 monotonous tasks were needed for each release, which easily took up to 30-60 minutes out of our day."),Object(r.mdx)("p",null,"To distribute the pain, each month we would nominate someone as the release marshal, who inherited the responsibilities of handling all of the release tasks.\nIt was an inefficient, joyless process that we all resented.\nSomething needed to change."),Object(r.mdx)("hr",null),Object(r.mdx)("h2",{id:"the-solution"},Object(r.mdx)("a",Object(a.a)({parentName:"h2"},{className:'header-link no-underline text-gray-900" hover:underline',href:"#the-solution"}),"The Solution")),Object(r.mdx)("p",null,"Auto started as a simple Node script that made a few requests to the GitHub API.\nIt gathered the commits merged from the last release and posted those to GitHub.\nWe still had some manual steps in the release process, but it was the start of the end of the monotony."),Object(r.mdx)("p",null,"I brought in another engineer on my team, ",Object(r.mdx)("a",Object(a.a)({parentName:"p"},{href:"https://www.linkedin.com/in/andrew-lisowski-8b419977/"}),"Andrew Lisowski"),', and we spent the next few months building out the script into a proper npm module.\nWe gave it a well-defined API comprised of small atomic operations that could handle all parts of the release.\nWith auto, the new process is entirely hands-off\u200a\u2014\u200asimply hit "merge", and everything happens automatically.'),Object(r.mdx)("p",null,"We initially crafted auto to solve for our team's specific release process\u200a\u2014\u200awhich needed to post comments and statuses back to a pull request, generate release notes based on what was merged, and document these releases on GitHub and Slack.\nWe eliminated the need for a dedicated release marshal, instead opting for each engineer to annotate their pull requests with a proper semantic version label.\nAuto would then take it from there, deploying and documenting the release without the need for manual intervention.\nAfter dogfooding auto internally for about six months, there was a lot of interest from outside teams, and we knew each of them had slightly different release pipelines, so we worked to make it reusable and customizable for anyone that wanted to use it."),Object(r.mdx)("p",null,"Andrew and I had been talking about using TypeScript for a while and decided that this was a perfect project to start out.\nBy bringing static type-checking to our JavaScript code, refactoring became much less painful, as types quickly caught would-be bugs much sooner.\nSince writing auto, we've made it a point to use TypeScript as our de facto language in any new project we create, including many of the front-end components used in TurboTax today."),Object(r.mdx)("p",null,"Inspired by the power and modularity of webpack's plugin architecture, we brought in their tap-able module, the core code that powers their plugins.\nAndrew and I spent about a month slowly refactoring the code to leverage the plugin-based architecture you see today.\nIt went live on ",Object(r.mdx)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/intuit/auto"}),"GitHub")," in December 2018 and has since attracted several outside contributors."),Object(r.mdx)("p",null,"Andrew was also getting more involved in the open source community at Intuit, and auto seemed like a great fit for a project to release next\u200a\u2014\u200aany work that we'd need to do to make auto pluggable for teams inside of Intuit also meant that teams outside of Intuit could leverage it."),Object(r.mdx)("p",null,"While a few libraries with similar capabilities already exist, we had yet to identify one that truly met our needs.\nPackages such as semantic-release were a great inspiration to auto-calculate a version bump based on merged changes, but require a significant change to a developer's workflow, something we weren't prepared to enforce."),Object(r.mdx)("p",null,'Auto\'s philosophy is to compose each part of the release pipeline into a series of plugins, allowing it to handle a bunch of different use-cases out of the box.\nUltimately it boils down to two commands: "auto init" to get started and "auto shipit" to release.\nAnyone can write a plugin for any part of the release process and add their own custom handlers, without having to change the core system.\nIf instead of publishing to npm, you want to publish an extension to the Chrome Web Store, simply enable that plugin and auto will handle the rest for you.'),Object(r.mdx)("p",null,"We were pleasantly surprised by how quickly auto was picked up by the community.\nIt filled a niche that the existing libraries didn't quite cover.\nBy using labels\u200a\u2014\u200ainstead of specially formatted commit messages required by some existing solutions\u200a\u2014\u200awe were able to significantly lower the barriers to entry for auto.\nAuto doesn't impede the developer workflow\u200a\u2014\u200ajust throw a label on a pull request and continue to focus on code."),Object(r.mdx)("p",null,"Working on auto from the start has been an amazing experience\u200a\u2014\u200anot only did it help our team, but it's awesome to see other teams integrating it into their releases.\nI'm really happy that we got to share it with the open source community and am excited to see where the future takes it next."))}m.isMDXComponent=!0}},[["EyFH",0,1,2,3,5]]]);